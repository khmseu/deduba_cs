<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Library</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <RuntimeIdentifiers>win-x64;linux-x64</RuntimeIdentifiers>
    <CMakeBuildFlags />
    <CMakeBuildFlags Condition="'$(CMakeGenerator)' == 'Ninja'">
      -- -j4
    </CMakeBuildFlags
    >
    <CMakeBuildFlags Condition="'$(CMakeGenerator)' != '' and '$(CMakeGenerator)' != 'Ninja'">
      -- /m
    </CMakeBuildFlags
    >
  </PropertyGroup>
  <!-- Windows DLL will be built using MSBuild/CMake in the future -->
  <!-- For now, this is a placeholder project -->
  <ItemGroup>
    <None Include="README.md" />
  </ItemGroup>
  <!-- Cross-compile native DLL via CMake only for Windows RID builds (win-x64) -->
  <!-- Configure toolchain only for non-Windows (cross builds); on Windows use VS generator natively -->
  <PropertyGroup Condition="'$(OS)' != 'Windows_NT'">
    <!-- Use MSBuildProjectDirectory instead of MSBuildThisFileDirectory to avoid trailing backslash issues -->
    <NativeBuildDir>$(MSBuildProjectDirectory)/build-win-x64</NativeBuildDir>
    <CMakeToolchainFile>$(MSBuildProjectDirectory)/cmake/toolchains/mingw-w64-x86_64.cmake</CMakeToolchainFile>
  </PropertyGroup>
  <PropertyGroup Condition="'$(OS)' == 'Windows_NT'">
    <NativeBuildDir>$(MSBuildProjectDirectory)/build-win-x64</NativeBuildDir>
    <!-- Ensure no cross toolchain file is passed on Windows -->
    <CMakeToolchainFile></CMakeToolchainFile>
  </PropertyGroup>
  <PropertyGroup>
    <!-- Platform-aware CMake generator and args.
         On Windows we want to rely on CMake defaults (Visual Studio generator
         if available), so leave $(CMakeGenerator) empty. On non-Windows we
         explicitly use Ninja and a mingw toolchain file. The CMakeGeneratorFlag
         property below expands to "-G <generator>" only when a generator is set. -->
    <CMakeGenerator Condition="'$(OS)' != 'Windows_NT'">Ninja</CMakeGenerator>
    <!-- When building on Windows, explicitly select the Visual Studio generator and platform
          to ensure the generated VS solution correctly targets x64. This avoids CMake creating
          a Win32 project that in turn compiles with a mismatched architecture and causes
          the 'No Target Architecture' error in Windows SDK headers. -->
    <CMakeGenerator Condition="'$(OS)' == 'Windows_NT'">Visual Studio 17 2022</CMakeGenerator>
  </PropertyGroup>
  <PropertyGroup Condition="'$(OS)' == 'Windows_NT'">
    <!-- Force x64 platform selection across CMake + VS generators to avoid
         missing target architecture macros in Windows SDK headers -->
    <CMakeGeneratorExtraArgs>-A x64 -DCMAKE_GENERATOR_PLATFORM=x64 -DCMAKE_VS_PLATFORM_NAME=x64</CMakeGeneratorExtraArgs>
  </PropertyGroup>
  <PropertyGroup Condition="'$(OS)' != 'Windows_NT'">
    <CMakeGeneratorExtraArgs>-DCMAKE_TOOLCHAIN_FILE=$(CMakeToolchainFile)</CMakeGeneratorExtraArgs>
  </PropertyGroup>
  <PropertyGroup>
    <CMakeGeneratorFlag Condition="'$(CMakeGenerator)' != ''"
      >-G "$(CMakeGenerator)"</CMakeGeneratorFlag
    >
  </PropertyGroup>
  <!-- MSBuild platform args for cmake build on Windows to ensure x64 -->
  <PropertyGroup Condition="'$(OS)' == 'Windows_NT'">
    <CMakeBuildPlatformArgs>-- /p:Platform=x64</CMakeBuildPlatformArgs>
  </PropertyGroup>
  <PropertyGroup Condition="'$(OS)' != 'Windows_NT'">
    <CMakeBuildPlatformArgs></CMakeBuildPlatformArgs>
  </PropertyGroup>
  <ItemGroup>
    <!-- Native runtime libraries; copy them into managed output to make them locatable by the
    P/Invoke loader.
         Some generators / toolchains prepend 'lib' and/or place the file at different output paths, so
    include
         the likely names/locations that the CMake generator may produce. -->
    <None Update="build-win-x64/bin/OsCallsWindowsShimNative.dll">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
    <None Update="build-win-x64/bin/OsCallsWindowsShim.dll">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
    <None Update="build-win-x64/bin/libOsCallsWindowsShim.dll">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
    <!-- Also keep per-configuration/browser RID variant paths in case other runners produce these
    locations -->
    <None Update="build-win-x64/bin/$(Configuration)/net8.0/win-x64/OsCallsWindowsShimNative.dll">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
    <None Update="build-win-x64/bin/$(Configuration)/OsCallsWindowsShimNative.dll">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>
  <Target
    Name="ConfigureNative"
    Condition="('$(RuntimeIdentifier)' == 'win-x64') Or ('$(OS)' == 'Windows_NT')"
    BeforeTargets="Build"
  >
    <Message Text="Configuring CMake into $(NativeBuildDir)" Importance="High" />
    <MakeDir Directories="$(NativeBuildDir)" />
    <!-- Run CMake from the project directory to avoid trailing backslash/quote issues when
         invoked under PowerShell. Use $(CMakeGeneratorFlag) if a generator is configured,
         otherwise rely on CMake defaults on the host. -->
    <Message Text="CMake generator flag: $(CMakeGeneratorFlag)" Importance="Low" />
    <Message Text="CMake extra args: $(CMakeGeneratorExtraArgs)" Importance="High" />
    <Exec
      WorkingDirectory="$(MSBuildProjectDirectory)"
      Command="cmake $(CMakeGeneratorFlag) -S . -B &quot;$(NativeBuildDir)&quot; $(CMakeGeneratorExtraArgs)"
    />
  </Target>
  <Target
    Name="BuildNative"
    Condition="('$(RuntimeIdentifier)' == 'win-x64') Or ('$(OS)' == 'Windows_NT')"
    DependsOnTargets="ConfigureNative"
    BeforeTargets="Build"
  >
    <Message
      Text="Building native OsCallsWindowsShim via CMake in $(NativeBuildDir)"
      Importance="High"
    />
    <!-- Build with optional tool flags: use -j for ninja, /m for MSBuild generator (when explicitly set).
         On Windows, pass /p:Platform=x64 to MSBuild via double-dash to ensure MSVC defines _M_X64. -->
    <Exec Command="cmake --build &quot;$(NativeBuildDir)&quot; --config $(Configuration) $(CMakeBuildFlags) $(CMakeBuildPlatformArgs)" />
  </Target>
  <Target Name="CopySharedLibrary" AfterTargets="Build">
    <ItemGroup>
      <!-- Include multiple possible names and paths that the CMake build may produce. The Copy task
      ignores missing
           files if we guard using the Condition attribute on the copy operation. -->
      <SharedLib Include="$(MSBuildThisFileDirectory)build-win-x64/bin/OsCallsWindowsShimNative.dll" />
      <SharedLib Include="$(MSBuildThisFileDirectory)build-win-x64/bin/libOsCallsWindowsShim.dll" />
      <SharedLib Include="$(MSBuildThisFileDirectory)build-win-x64/bin/OsCallsWindowsShim.dll" />
      <SharedLib Include="$(MSBuildThisFileDirectory)build-win-x64/bin/$(Configuration)/net8.0/win-x64/OsCallsWindowsShimNative.dll" />
      <SharedLib Include="$(MSBuildThisFileDirectory)build-win-x64/bin/$(Configuration)/OsCallsWindowsShimNative.dll" />
      <SharedLib Include="$(MSBuildThisFileDirectory)bin/$(Configuration)/net8.0/win-x64/OsCallsWindowsShimNative.dll" />
    </ItemGroup>
    <!-- Copy to the expected name so the managed LibraryImport 'OsCallsWindowsShimNative.dll' will
    be resolved. -->
    <Copy
      SourceFiles="@(SharedLib)"
      DestinationFiles="@(SharedLib-&gt;'$(OutputPath)OsCallsWindowsShimNative.dll')"
      Condition="Exists('%(SharedLib.Identity)')"
      SkipUnchangedFiles="true"
    />
  </Target>
  <Target Name="CleanNative" Condition="Exists('$(NativeBuildDir)')" AfterTargets="Clean">
    <Message Text="Cleaning native build directory $(NativeBuildDir)" Importance="Low" />
    <RemoveDir Directories="$(NativeBuildDir)" />
  </Target>
</Project>
