using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class RecursiveFunctionExample
{
    public static void Mainxx(string[] args)
    {
        int? nullableInt = 5;
        int valueInt = 10;
        List<int> enumerableValue = new List<int> { 1, 2, 3 };

        Console.WriteLine(Process(nullableInt, "nullableInt"));
        Console.WriteLine(Process(valueInt, "valueInt"));
        Console.WriteLine(Process(enumerableValue, "enumerableValue"));
    }

    // Überladung für Nullable-Typen
    private static string Process<T>(T? value, string name) where T : struct
    {
        if (name == null) throw new ArgumentNullException(nameof(name));
        return value is null ? "Nullable type is null" : Process(value.Value, name);
    }

    // Überladung für Werttypen
    private static string Process<T>(T value, string name) where T : struct
    {
        if (name == null) throw new ArgumentNullException(nameof(name));

        var result = new List<string>();
        foreach (var item in value)
        {
            result.Add(Process(item, ""));
        }
        return $"Enumerable type: [{string.Join(", ", result)}]";
    }
    // Überladung für Werttypen
    private static string Process<T>(T value, string name) where T : class
    {
        if (name == null) throw new ArgumentNullException(nameof(name));

        var result = new List<string>();
        foreach (var item in value)
        {
            result.Add(Process(item, ""));
        }
        return $"Enumerable type: [{string.Join(", ", result)}]";
    }

    // Überladung für Objekte (Fallback)
    private static string Process(object value, string name)
    {
        if (name == null) throw new ArgumentNullException(nameof(name));
        return $"Object type: {value}";
    }
}