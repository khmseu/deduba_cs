[
  {
    "extension_dir": "/home/kai/.vscode/extensions/cweijan.vscode-postgresql-client2-8.3.4",
    "publisher": "cweijan",
    "name": "vscode-postgresql-client2",
    "displayName": "PostgreSQL",
    "version": "8.3.4",
    "package_json": "/home/kai/.vscode/extensions/cweijan.vscode-postgresql-client2-8.3.4/package.json",
    "tools": [
      {
        "name": "dbclient-get-databases",
        "tags": ["editors", "dbclient", "vscode-editing"],
        "toolReferenceName": "dbclient-getDatabases",
        "canBeReferencedInPrompt": true,
        "displayName": "%mcp.languageModelTools.dbclient-get-databases.displayName%",
        "modelDescription": "%mcp.languageModelTools.dbclient-get-databases.modelDescription%",
        "icon": "resources/databases.png",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "dbclient-get-tables",
        "tags": ["editors", "dbclient", "vscode-editing"],
        "toolReferenceName": "dbclient-getTables",
        "canBeReferencedInPrompt": true,
        "displayName": "%mcp.languageModelTools.dbclient-get-tables.displayName%",
        "modelDescription": "%mcp.languageModelTools.dbclient-get-tables.modelDescription%",
        "icon": "resources/databases.png",
        "inputSchema": {
          "type": "object",
          "properties": {
            "databaseOrSchemaName": {
              "type": "string",
              "description": "The name of the database or schema."
            }
          },
          "required": []
        }
      },
      {
        "name": "dbclient-execute-query",
        "tags": ["editors", "dbclient", "vscode-editing"],
        "toolReferenceName": "dbclient-executeQuery",
        "canBeReferencedInPrompt": true,
        "displayName": "%mcp.languageModelTools.dbclient-execute-query.displayName%",
        "modelDescription": "%mcp.languageModelTools.dbclient-execute-query.modelDescription%",
        "userDescription": "%mcp.languageModelTools.dbclient-execute-query.userDescription%",
        "icon": "resources/databases.png",
        "inputSchema": {
          "type": "object",
          "properties": {
            "databaseOrSchemaName": {
              "type": "string",
              "description": "The name of the database or schema."
            },
            "query": {
              "type": "string",
              "description": "The query to execute."
            }
          },
          "required": ["query"]
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/dbcode.dbcode-1.21.2",
    "publisher": "dbcode",
    "name": "dbcode",
    "displayName": "DBCode - Database Management",
    "version": "1.21.2",
    "package_json": "/home/kai/.vscode/extensions/dbcode.dbcode-1.21.2/package.json",
    "tools": [
      {
        "name": "dbcode-get-connections",
        "tags": ["editors", "dbcode", "vscode-editing"],
        "toolReferenceName": "dbcode-getConnections",
        "canBeReferencedInPrompt": true,
        "displayName": "%Retrieve Connections%",
        "icon": "out/resources/logos/icon_color.svg",
        "modelDescription": "Retrieve available connections. Returns a list of connections, including the name, id, type. The connection id and connection name values are required to access the other dbcode tools.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "dbcode-workspace-connection",
        "tags": ["editors", "dbcode", "vscode-editing"],
        "toolReferenceName": "dbcode-workspaceConnection",
        "canBeReferencedInPrompt": true,
        "displayName": "%Workspace Connection%",
        "icon": "out/resources/logos/icon_color.svg",
        "modelDescription": "Default connection: if the user does not specifically mention a connection this will provide the default connection if configured. It will return the name and id and type of the connection along with the database and schema names if applicable if a default connection is specified. This information can then be used to execute queries in the default connection for the current workspace.",
        "userDescription": "%Provide the configured default workspace connection.%",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "dbcode-get-databases",
        "tags": ["editors", "dbcode", "vscode-editing"],
        "toolReferenceName": "dbcode-getDatabases",
        "canBeReferencedInPrompt": true,
        "displayName": "%Retrieve Databases%",
        "modelDescription": "Retrieve all available databases for a specified connection.",
        "icon": "out/resources/logos/icon_color.svg",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "type": "string",
              "description": "The unique connection id, obtained from the dbcode-get-connections tool. (required)"
            },
            "connectionName": {
              "type": "string",
              "description": "The name of the connection, obtained from the dbcode-get-connections tool. (required)"
            }
          },
          "required": ["connectionId", "connectionName"]
        }
      },
      {
        "name": "dbcode-get-schemas",
        "tags": ["editors", "dbcode", "vscode-editing"],
        "toolReferenceName": "dbcode-getSchemas",
        "canBeReferencedInPrompt": true,
        "displayName": "%Retrieve Schemas%",
        "icon": "out/resources/logos/icon_color.svg",
        "modelDescription": "Retrieve the schema names for a database, if the database supports schemas.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "type": "string",
              "description": "The unique connection id, obtained from the dbcode-get-connections tool. (required)"
            },
            "connectionName": {
              "type": "string",
              "description": "The name of the connection, obtained from the dbcode-get-connections tool. (required)"
            },
            "databaseName": {
              "type": "string",
              "description": "The name of the database. (required)"
            }
          },
          "required": ["connectionId", "connectionName", "databaseName"]
        }
      },
      {
        "name": "dbcode-get-tables",
        "tags": ["editors", "dbcode", "vscode-editing"],
        "toolReferenceName": "dbcode-getTables",
        "canBeReferencedInPrompt": true,
        "displayName": "%Retrieve Tables%",
        "icon": "out/resources/logos/icon_color.svg",
        "modelDescription": "Retrieve tables with their columns, foreign keys, primary keys and index information. Use tablePattern to filter by name if required.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "type": "string",
              "description": "The unique connection id, obtained from the dbcode-get-connections tool. (required)"
            },
            "connectionName": {
              "type": "string",
              "description": "The name of the connection, obtained from the dbcode-get-connections tool. (required)"
            },
            "databaseName": {
              "type": "string",
              "description": "The name of the database. (required)"
            },
            "schemaName": {
              "type": "string",
              "description": "The name of the schema (only needed when the database supports schemas)."
            },
            "tablePattern": {
              "type": "string",
              "description": "Optional pattern to filter table names. Supports wildcards: * (any chars), ? (single char). Case-insensitive. Examples: 'user*' matches 'users', 'user_profile'; '*order*' matches tables containing 'order'."
            }
          },
          "required": ["connectionId", "connectionName", "databaseName"]
        }
      },
      {
        "name": "dbcode-execute-query",
        "tags": ["editors", "dbcode", "vscode-editing"],
        "toolReferenceName": "dbcode-executeQuery",
        "canBeReferencedInPrompt": true,
        "displayName": "%Execute Query%",
        "icon": "out/resources/logos/icon_color.svg",
        "modelDescription": "Executes a read-only query (SELECT) in the specified database and optional schema. For data modification (INSERT, UPDATE, DELETE, etc), use dbcode-execute-dml. For schema changes (CREATE, DROP, ALTER, etc), use dbcode-execute-ddl.",
        "userDescription": "%Executes a query in the specified database and optional schema.%",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "type": "string",
              "description": "The unique connection id, obtained from the dbcode-get-connections tool. (required)"
            },
            "connectionName": {
              "type": "string",
              "description": "The name of the connection, obtained from the dbcode-get-connections tool. (required)"
            },
            "databaseName": {
              "type": "string",
              "description": "The name of the database. (required)"
            },
            "schemaName": {
              "type": "string",
              "description": "The name of the schema (only needed when the database supports schemas)."
            },
            "query": {
              "type": "string",
              "description": "The query to execute. (required)"
            }
          },
          "required": [
            "connectionId",
            "connectionName",
            "databaseName",
            "query"
          ]
        }
      },
      {
        "name": "dbcode-execute-dml",
        "tags": ["editors", "dbcode", "vscode-editing"],
        "toolReferenceName": "dbcode-executeDML",
        "canBeReferencedInPrompt": true,
        "displayName": "%Execute DML%",
        "icon": "out/resources/logos/icon_color.svg",
        "modelDescription": "Executes a DML statement (INSERT, UPDATE, DELETE) in the specified database and optional schema. Use this tool when you need to modify data. For read-only queries, use dbcode-execute-query. For schema changes, use dbcode-execute-ddl.",
        "userDescription": "%Executes a DML statement (INSERT, UPDATE, DELETE) in the specified database and optional schema.%",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "type": "string",
              "description": "The unique connection id, obtained from the dbcode-get-connections tool. (required)"
            },
            "connectionName": {
              "type": "string",
              "description": "The name of the connection, obtained from the dbcode-get-connections tool. (required)"
            },
            "databaseName": {
              "type": "string",
              "description": "The name of the database. (required)"
            },
            "schemaName": {
              "type": "string",
              "description": "The name of the schema (only needed when the database supports schemas)."
            },
            "statement": {
              "type": "string",
              "description": "The DML statement to execute. (required)"
            }
          },
          "required": [
            "connectionId",
            "connectionName",
            "databaseName",
            "statement"
          ]
        }
      },
      {
        "name": "dbcode-execute-ddl",
        "tags": ["editors", "dbcode", "vscode-editing"],
        "toolReferenceName": "dbcode-executeDDL",
        "canBeReferencedInPrompt": true,
        "displayName": "%Execute DDL%",
        "icon": "out/resources/logos/icon_color.svg",
        "modelDescription": "Executes a DDL statement (CREATE, DROP, ALTER, TRUNCATE, etc.) in the specified database and optional schema. Use this tool when you need to modify database schema. For data modification, use dbcode-execute-dml. For read-only queries, use dbcode-execute-query.",
        "userDescription": "%Executes a DDL statement (CREATE, DROP, ALTER, TRUNCATE, etc.) in the specified database and optional schema.%",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "type": "string",
              "description": "The unique connection id, obtained from the dbcode-get-connections tool. (required)"
            },
            "connectionName": {
              "type": "string",
              "description": "The name of the connection, obtained from the dbcode-get-connections tool. (required)"
            },
            "databaseName": {
              "type": "string",
              "description": "The name of the database. (required)"
            },
            "schemaName": {
              "type": "string",
              "description": "The name of the schema (only needed when the database supports schemas)."
            },
            "statement": {
              "type": "string",
              "description": "The DDL statement to execute. (required)"
            }
          },
          "required": [
            "connectionId",
            "connectionName",
            "databaseName",
            "statement"
          ]
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/dsanders11.vscode-electron-build-tools-0.38.3",
    "publisher": "dsanders11",
    "name": "vscode-electron-build-tools",
    "displayName": "Electron Build Tools",
    "version": "0.38.3",
    "package_json": "/home/kai/.vscode/extensions/dsanders11.vscode-electron-build-tools-0.38.3/package.json",
    "tools": [
      {
        "name": "electron-build-tools_chromiumGitLog",
        "tags": ["chromium", "git", "log", "commits"],
        "displayName": "Chromium Git Log",
        "modelDescription": "Retrieves the git log for Chromium between two versions",
        "inputSchema": {
          "type": "object",
          "properties": {
            "startVersion": {
              "type": "string",
              "description": "The starting version to retrieve the log for.",
              "examples": ["135.0.7016.3", "135.0.7049.1"]
            },
            "endVersion": {
              "type": "string",
              "description": "The ending version to retrieve the log for.",
              "examples": ["135.0.7016.3", "135.0.7049.1"]
            },
            "page": {
              "type": "integer",
              "description": "The page number of the log to retrieve.",
              "minimum": 1
            }
          }
        }
      },
      {
        "name": "electron-build-tools_chromiumGitShow",
        "tags": ["chromium", "git", "show", "commits"],
        "displayName": "Chromium Git Show",
        "modelDescription": "Shows the log message and textual diff for a commit",
        "inputSchema": {
          "type": "object",
          "properties": {
            "commit": {
              "type": "string",
              "description": "The SHA for the commit to show.",
              "examples": ["26b69cddcef09655077629eeda8000f4ba621f5f"]
            }
          },
          "required": ["commit"]
        }
      },
      {
        "name": "electron-build-tools_gitLog",
        "tags": ["git", "log", "commits"],
        "displayName": "Git Log",
        "modelDescription": "Retrieves the git log for a given filename",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filename": {
              "type": "string",
              "description": "The filename to retrieve the git log for.",
              "examples": [
                "chrome/browser/icon_loader.cc",
                "components/autofill/core/browser/geo/autofill_country.h"
              ]
            }
          },
          "required": ["filename"]
        }
      },
      {
        "name": "electron-build-tools_gitShow",
        "tags": ["git", "show", "commits"],
        "displayName": "Git Show",
        "modelDescription": "Shows the log message and textual diff for a commit",
        "inputSchema": {
          "type": "object",
          "properties": {
            "commit": {
              "type": "string",
              "description": "The SHA for the commit to show.",
              "examples": ["26b69cddcef09655077629eeda8000f4ba621f5f"]
            },
            "filename": {
              "type": "string",
              "description": "The filename to limit the textual diff to.",
              "examples": [
                "chrome/browser/icon_loader.cc",
                "electron/shell/utility/electron_content_utility_client.h"
              ]
            }
          },
          "required": ["commit", "filename"]
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/github.copilot-chat-0.35.0",
    "publisher": "GitHub",
    "name": "copilot-chat",
    "displayName": "GitHub Copilot Chat",
    "version": "0.35.0",
    "package_json": "/home/kai/.vscode/extensions/github.copilot-chat-0.35.0/package.json",
    "tools": [
      {
        "name": "copilot_searchCodebase",
        "toolReferenceName": "codebase",
        "displayName": "%copilot.tools.searchCodebase.name%",
        "icon": "$(folder)",
        "userDescription": "%copilot.codebase.tool.description%",
        "modelDescription": "Run a natural language search for relevant code or documentation comments from the user's current workspace. Returns relevant code snippets from the user's current workspace if it is large, or the full contents of the workspace if it is small.",
        "tags": ["codesearch", "vscode_codesearch"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The query to search the codebase for. Should contain all relevant context. Should ideally be text that might appear in the codebase, such as function names, variable names, or comments."
            }
          },
          "required": ["query"]
        }
      },
      {
        "name": "copilot_searchWorkspaceSymbols",
        "toolReferenceName": "symbols",
        "displayName": "%copilot.tools.searchWorkspaceSymbols.name%",
        "icon": "$(symbol)",
        "userDescription": "%copilot.workspaceSymbols.tool.description%",
        "modelDescription": "Search the user's workspace for code symbols using language services. Use this tool when the user is looking for a specific symbol in their workspace.",
        "tags": ["vscode_codesearch"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbolName": {
              "type": "string",
              "description": "The symbol to search for, such as a function name, class name, or variable name."
            }
          },
          "required": ["symbolName"]
        }
      },
      {
        "name": "copilot_listCodeUsages",
        "toolReferenceName": "usages",
        "legacyToolReferenceFullNames": ["usages"],
        "displayName": "%copilot.tools.listCodeUsages.name%",
        "icon": "$(references)",
        "userDescription": "%copilot.listCodeUsages.tool.description%",
        "modelDescription": "Request to list all usages (references, definitions, implementations etc) of a function, class, method, variable etc. Use this tool when \n1. Looking for a sample implementation of an interface or class\n2. Checking how a function is used throughout the codebase.\n3. Including and updating all usages when changing a function, method, or constructor",
        "tags": ["vscode_codesearch"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbolName": {
              "type": "string",
              "description": "The name of the symbol, such as a function name, class name, method name, variable name, etc."
            },
            "filePaths": {
              "type": "array",
              "description": "One or more file paths which likely contain the definition of the symbol. For instance the file which declares a class or function. This is optional but will speed up the invocation of this tool and improve the quality of its output.",
              "items": {
                "type": "string"
              }
            }
          },
          "required": ["symbolName"]
        }
      },
      {
        "name": "copilot_getVSCodeAPI",
        "toolReferenceName": "vscodeAPI",
        "displayName": "%copilot.tools.getVSCodeAPI.name%",
        "icon": "$(references)",
        "userDescription": "%copilot.vscode.tool.description%",
        "modelDescription": "Get comprehensive VS Code API documentation and references for extension development. This tool provides authoritative documentation for VS Code's extensive API surface, including proposed APIs, contribution points, and best practices. Use this tool for understanding complex VS Code API interactions.\n\nWhen to use this tool:\n- User asks about specific VS Code APIs, interfaces, or extension capabilities\n- Need documentation for VS Code extension contribution points (commands, views, settings, etc.)\n- Questions about proposed APIs and their usage patterns\n- Understanding VS Code extension lifecycle, activation events, and packaging\n- Best practices for VS Code extension development architecture\n- API examples and code patterns for extension features\n- Troubleshooting extension-specific issues or API limitations\n\nWhen NOT to use this tool:\n- Creating simple standalone files or scripts unrelated to VS Code extensions\n- General programming questions not specific to VS Code extension development\n- Questions about using VS Code as an editor (user-facing features)\n- Non-extension related development tasks\n- File creation or editing that doesn't involve VS Code extension APIs\n\nCRITICAL usage guidelines:\n1. Always include specific API names, interfaces, or concepts in your query\n2. Mention the extension feature you're trying to implement\n3. Include context about proposed vs stable APIs when relevant\n4. Reference specific contribution points when asking about extension manifest\n5. Be specific about the VS Code version or API version when known\n\nScope: This tool is for EXTENSION DEVELOPMENT ONLY - building tools that extend VS Code itself, not for general file creation or non-extension programming tasks.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The query to search vscode documentation for. Should contain all relevant context."
            }
          },
          "required": ["query"]
        },
        "tags": []
      },
      {
        "name": "copilot_findFiles",
        "toolReferenceName": "fileSearch",
        "displayName": "%copilot.tools.findFiles.name%",
        "modelDescription": "Search for files in the workspace by glob pattern. This only returns the paths of matching files. Use this tool when you know the exact filename pattern of the files you're searching for. Glob patterns match from the root of the workspace folder. Examples:\n- **/*.{js,ts} to match all js/ts files in the workspace.\n- src/** to match all files under the top-level src folder.\n- **/foo/**/*.js to match all js files under any foo folder in the workspace.",
        "tags": ["vscode_codesearch"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search for files with names or paths matching this glob pattern."
            },
            "maxResults": {
              "type": "number",
              "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
            }
          },
          "required": ["query"]
        }
      },
      {
        "name": "copilot_findTextInFiles",
        "toolReferenceName": "textSearch",
        "displayName": "%copilot.tools.findTextInFiles.name%",
        "modelDescription": "Do a fast text search in the workspace. Use this tool when you want to search with an exact string or regex. If you are not sure what words will appear in the workspace, prefer using regex patterns with alternation (|) or character classes to search for multiple potential words at once instead of making separate searches. For example, use 'function|method|procedure' to look for all of those words at once. Use includePattern to search within files matching a specific pattern, or in a specific file, using a relative path. Use 'includeIgnoredFiles' to include files normally ignored by .gitignore, other ignore files, and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower, only set it when you want to search in ignored folders like node_modules or build outputs. Use this tool when you want to see an overview of a particular file, instead of using read_file many times to look for code within a file.",
        "tags": ["vscode_codesearch"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The pattern to search for in files in the workspace. Use regex with alternation (e.g., 'word1|word2|word3') or character classes to find multiple potential words in a single search. Be sure to set the isRegexp property properly to declare whether it's a regex or plain text pattern. Is case-insensitive."
            },
            "isRegexp": {
              "type": "boolean",
              "description": "Whether the pattern is a regex."
            },
            "includePattern": {
              "type": "string",
              "description": "Search files matching this glob pattern. Will be applied to the relative path of files within the workspace. To search recursively inside a folder, use a proper glob pattern like \"src/folder/**\". Do not use | in includePattern."
            },
            "maxResults": {
              "type": "number",
              "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
            },
            "includeIgnoredFiles": {
              "type": "boolean",
              "description": "Whether to include files that would normally be ignored according to .gitignore, other ignore files and `files.exclude` and `search.exclude` settings. Warning: using this may cause the search to be slower. Only set it when you want to search in ignored folders like node_modules or build outputs."
            }
          },
          "required": ["query", "isRegexp"]
        }
      },
      {
        "name": "copilot_applyPatch",
        "displayName": "%copilot.tools.applyPatch.name%",
        "toolReferenceName": "applyPatch",
        "userDescription": "%copilot.tools.applyPatch.description%",
        "modelDescription": "Edit text files. Do not use this tool to edit Jupyter notebooks. `apply_patch` allows you to execute a diff/patch against a text file, but the format of the diff specification is unique to this task, so pay careful attention to these instructions. To use the `apply_patch` command, you should pass a message of the following structure as \"input\":\n\n*** Begin Patch\n[YOUR_PATCH]\n*** End Patch\n\nWhere [YOUR_PATCH] is the actual content of your patch, specified in the following V4A diff format.\n\n*** [ACTION] File: [/absolute/path/to/file] -> ACTION can be one of Add, Update, or Delete.\nAn example of a message that you might pass as \"input\" to this function, in order to apply a patch, is shown below.\n\n*** Begin Patch\n*** Update File: /Users/someone/pygorithm/searching/binary_search.py\n@@class BaseClass\n@@    def search():\n-        pass\n+        raise NotImplementedError()\n\n@@class Subclass\n@@    def search():\n-        pass\n+        raise NotImplementedError()\n\n*** End Patch\nDo not use line numbers in this diff format.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "input": {
              "type": "string",
              "description": "The edit patch to apply."
            },
            "explanation": {
              "type": "string",
              "description": "A short description of what the tool call is aiming to achieve."
            }
          },
          "required": ["input", "explanation"]
        }
      },
      {
        "name": "copilot_readFile",
        "toolReferenceName": "readFile",
        "legacyToolReferenceFullNames": ["search/readFile"],
        "displayName": "%copilot.tools.readFile.name%",
        "userDescription": "%copilot.tools.readFile.userDescription%",
        "modelDescription": "Read the contents of a file.\n\nYou must specify the line range you're interested in. Line numbers are 1-indexed. If the file contents returned are insufficient for your task, you may call this tool again to retrieve more content. Prefer reading larger ranges over doing many small reads.",
        "tags": ["vscode_codesearch"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "description": "The absolute path of the file to read.",
              "type": "string"
            },
            "startLine": {
              "type": "number",
              "description": "The line number to start reading from, 1-based."
            },
            "endLine": {
              "type": "number",
              "description": "The inclusive line number to end reading at, 1-based."
            }
          },
          "required": ["filePath", "startLine", "endLine"]
        }
      },
      {
        "name": "copilot_listDirectory",
        "toolReferenceName": "listDirectory",
        "displayName": "%copilot.tools.listDirectory.name%",
        "modelDescription": "List the contents of a directory. Result will have the name of the child. If the name ends in /, it's a folder, otherwise a file",
        "tags": ["vscode_codesearch"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "The absolute path to the directory to list."
            }
          },
          "required": ["path"]
        }
      },
      {
        "name": "copilot_getErrors",
        "displayName": "%copilot.tools.getErrors.name%",
        "toolReferenceName": "problems",
        "legacyToolReferenceFullNames": ["problems"],
        "icon": "$(error)",
        "userDescription": "%copilot.tools.errors.description%",
        "modelDescription": "Get any compile or lint errors in a specific file or across all files. If the user mentions errors or problems in a file, they may be referring to these. Use the tool to see the same errors that the user is seeing. If the user asks you to analyze all errors, or does not specify a file, use this tool to gather errors for all files. Also use this tool after editing a file to validate the change.",
        "tags": [],
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePaths": {
              "description": "The absolute paths to the files or folders to check for errors. Omit 'filePaths' when retrieving all errors.",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        }
      },
      {
        "name": "copilot_readProjectStructure",
        "displayName": "%copilot.tools.readProjectStructure.name%",
        "modelDescription": "Get a file tree representation of the workspace.",
        "tags": []
      },
      {
        "name": "copilot_getChangedFiles",
        "displayName": "%copilot.tools.getChangedFiles.name%",
        "toolReferenceName": "changes",
        "legacyToolReferenceFullNames": ["changes"],
        "icon": "$(diff)",
        "userDescription": "%copilot.tools.changes.description%",
        "modelDescription": "Get git diffs of current file changes in a git repository. Don't forget that you can use run_in_terminal to run git commands in a terminal as well.",
        "tags": ["vscode_codesearch"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "repositoryPath": {
              "type": "string",
              "description": "The absolute path to the git repository to look for changes in. If not provided, the active git repository will be used."
            },
            "sourceControlState": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": ["staged", "unstaged", "merge-conflicts"]
              },
              "description": "The kinds of git state to filter by. Allowed values are: 'staged', 'unstaged', and 'merge-conflicts'. If not provided, all states will be included."
            }
          }
        }
      },
      {
        "name": "copilot_testFailure",
        "toolReferenceName": "testFailure",
        "legacyToolReferenceFullNames": ["testFailure"],
        "displayName": "%copilot.tools.testFailure.name%",
        "icon": "$(beaker)",
        "userDescription": "%copilot.testFailure.tool.description%",
        "modelDescription": "Includes test failure information in the prompt.",
        "inputSchema": {},
        "tags": [
          "vscode_editing_with_tests",
          "enable_other_tool_copilot_readFile",
          "enable_other_tool_copilot_listDirectory",
          "enable_other_tool_copilot_findFiles",
          "enable_other_tool_copilot_runTests"
        ]
      },
      {
        "name": "copilot_updateUserPreferences",
        "toolReferenceName": "updateUserPreferences",
        "displayName": "%copilot.tools.updateUserPreferences.name%",
        "modelDescription": "Update the user's preferences file with new information about the user and their coding preferences, based on the current chat history.",
        "canBeReferencedInPrompt": true,
        "tags": [],
        "inputSchema": {
          "type": "object",
          "properties": {
            "facts": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "An array of new user preferences to remember."
            }
          },
          "required": ["facts"]
        },
        "when": "config.github.copilot.chat.enableUserPreferences"
      },
      {
        "name": "copilot_createNewWorkspace",
        "displayName": "%github.copilot.tools.createNewWorkspace.name%",
        "toolReferenceName": "newWorkspace",
        "legacyToolReferenceFullNames": ["new/newWorkspace"],
        "icon": "$(new-folder)",
        "userDescription": "%github.copilot.tools.createNewWorkspace.userDescription%",
        "when": "config.github.copilot.chat.newWorkspaceCreation.enabled",
        "modelDescription": "Get comprehensive setup steps to help the user create complete project structures in a VS Code workspace. This tool is designed for full project initialization and scaffolding, not for creating individual files.\n\nWhen to use this tool:\n- User wants to create a new complete project from scratch\n- Setting up entire project frameworks (TypeScript projects, React apps, Node.js servers, etc.)\n- Initializing Model Context Protocol (MCP) servers with full structure\n- Creating VS Code extensions with proper scaffolding\n- Setting up Next.js, Vite, or other framework-based projects\n- User asks for \"new project\", \"create a workspace\", \"set up a [framework] project\"\n- Need to establish complete development environment with dependencies, config files, and folder structure\n\nWhen NOT to use this tool:\n- Creating single files or small code snippets\n- Adding individual files to existing projects\n- Making modifications to existing codebases\n- User asks to \"create a file\" or \"add a component\"\n- Simple code examples or demonstrations\n- Debugging or fixing existing code\n\nThis tool provides complete project setup including:\n- Folder structure creation\n- Package.json and dependency management\n- Configuration files (tsconfig, eslint, etc.)\n- Initial boilerplate code\n- Development environment setup\n- Build and run instructions\n\nUse other file creation tools for individual files within existing projects.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The query to use to generate the new workspace. This should be a clear and concise description of the workspace the user wants to create."
            }
          },
          "required": ["query"]
        },
        "tags": [
          "enable_other_tool_install_extension",
          "enable_other_tool_get_project_setup_info"
        ]
      },
      {
        "name": "copilot_getProjectSetupInfo",
        "displayName": "%github.copilot.tools.getProjectSetupInfo.name%",
        "when": "config.github.copilot.chat.newWorkspaceCreation.enabled",
        "toolReferenceName": "getProjectSetupInfo",
        "legacyToolReferenceFullNames": ["new/getProjectSetupInfo"],
        "modelDescription": "Do not call this tool without first calling the tool to create a workspace. This tool provides a project setup information for a Visual Studio Code workspace based on a project type and programming language.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectType": {
              "type": "string",
              "description": "The type of project to create. Supported values are: 'python-script', 'python-project', 'mcp-server', 'model-context-protocol-server', 'vscode-extension', 'next-js', 'vite' and 'other'"
            }
          },
          "required": ["projectType"]
        },
        "tags": []
      },
      {
        "name": "copilot_installExtension",
        "displayName": "Install Extension in VS Code",
        "when": "config.github.copilot.chat.newWorkspaceCreation.enabled",
        "toolReferenceName": "installExtension",
        "legacyToolReferenceFullNames": ["new/installExtension"],
        "modelDescription": "Install an extension in VS Code. Use this tool to install an extension in Visual Studio Code as part of a new workspace creation process only.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the extension to install. This should be in the format <publisher>.<extension>."
            },
            "name": {
              "type": "string",
              "description": "The name of the extension to install. This should be a clear and concise description of the extension."
            }
          },
          "required": ["id", "name"]
        },
        "tags": []
      },
      {
        "name": "copilot_runVscodeCommand",
        "displayName": "Run VS Code Command",
        "when": "config.github.copilot.chat.newWorkspaceCreation.enabled",
        "toolReferenceName": "runCommand",
        "legacyToolReferenceFullNames": ["new/runVscodeCommand"],
        "modelDescription": "Run a command in VS Code. Use this tool to run a command in Visual Studio Code as part of a new workspace creation process only.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "commandId": {
              "type": "string",
              "description": "The ID of the command to execute. This should be in the format <command>."
            },
            "name": {
              "type": "string",
              "description": "The name of the command to execute. This should be a clear and concise description of the command."
            },
            "args": {
              "type": "array",
              "description": "The arguments to pass to the command. This should be an array of strings.",
              "items": {
                "type": "string"
              }
            }
          },
          "required": ["commandId", "name"]
        },
        "tags": []
      },
      {
        "name": "copilot_createNewJupyterNotebook",
        "displayName": "Create New Jupyter Notebook",
        "icon": "$(notebook)",
        "toolReferenceName": "createJupyterNotebook",
        "legacyToolReferenceFullNames": ["newJupyterNotebook"],
        "modelDescription": "Generates a new Jupyter Notebook (.ipynb) in VS Code. Jupyter Notebooks are interactive documents commonly used for data exploration, analysis, visualization, and combining code with narrative text. Prefer creating plain Python files or similar unless a user explicitly requests creating a new Jupyter Notebook or already has a Jupyter Notebook opened or exists in the workspace.",
        "userDescription": "%copilot.tools.newJupyterNotebook.description%",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The query to use to generate the jupyter notebook. This should be a clear and concise description of the notebook the user wants to create."
            }
          },
          "required": ["query"]
        },
        "tags": []
      },
      {
        "name": "copilot_insertEdit",
        "toolReferenceName": "insertEdit",
        "displayName": "%copilot.tools.insertEdit.name%",
        "modelDescription": "Insert new code into an existing file in the workspace. Use this tool once per file that needs to be modified, even if there are multiple changes for a file. Generate the \"explanation\" property first.\nThe system is very smart and can understand how to apply your edits to the files, you just need to provide minimal hints.\nAvoid repeating existing code, instead use comments to represent regions of unchanged code. Be as concise as possible. For example:\n// ...existing code...\n{ changed code }\n// ...existing code...\n{ changed code }\n// ...existing code...\n\nHere is an example of how you should use format an edit to an existing Person class:\nclass Person {\n\t// ...existing code...\n\tage: number;\n\t// ...existing code...\n\tgetAge() {\n\treturn this.age;\n\t}\n}",
        "tags": [],
        "inputSchema": {
          "type": "object",
          "properties": {
            "explanation": {
              "type": "string",
              "description": "A short explanation of the edit being made."
            },
            "filePath": {
              "type": "string",
              "description": "An absolute path to the file to edit."
            },
            "code": {
              "type": "string",
              "description": "The code change to apply to the file.\nThe system is very smart and can understand how to apply your edits to the files, you just need to provide minimal hints.\nAvoid repeating existing code, instead use comments to represent regions of unchanged code. Be as concise as possible. For example:\n// ...existing code...\n{ changed code }\n// ...existing code...\n{ changed code }\n// ...existing code...\n\nHere is an example of how you should use format an edit to an existing Person class:\nclass Person {\n\t// ...existing code...\n\tage: number;\n\t// ...existing code...\n\tgetAge() {\n\t\treturn this.age;\n\t}\n}"
            }
          },
          "required": ["explanation", "filePath", "code"]
        }
      },
      {
        "name": "copilot_createFile",
        "toolReferenceName": "createFile",
        "legacyToolReferenceFullNames": ["createFile"],
        "displayName": "%copilot.tools.createFile.name%",
        "userDescription": "%copilot.tools.createFile.description%",
        "modelDescription": "This is a tool for creating a new file in the workspace. The file will be created with the specified content. The directory will be created if it does not already exist. Never use this tool to edit a file that already exists.",
        "tags": [],
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute path to the file to create."
            },
            "content": {
              "type": "string",
              "description": "The content to write to the file."
            }
          },
          "required": ["filePath", "content"]
        }
      },
      {
        "name": "copilot_createDirectory",
        "toolReferenceName": "createDirectory",
        "legacyToolReferenceFullNames": ["createDirectory"],
        "displayName": "%copilot.tools.createDirectory.name%",
        "userDescription": "%copilot.tools.createDirectory.description%",
        "modelDescription": "Create a new directory structure in the workspace. Will recursively create all directories in the path, like mkdir -p. You do not need to use this tool before using create_file, that tool will automatically create the needed directories.",
        "tags": [],
        "inputSchema": {
          "type": "object",
          "properties": {
            "dirPath": {
              "type": "string",
              "description": "The absolute path to the directory to create."
            }
          },
          "required": ["dirPath"]
        }
      },
      {
        "name": "copilot_openSimpleBrowser",
        "displayName": "%copilot.tools.openSimpleBrowser.name%",
        "modelDescription": "Preview a website or open a URL in the editor's Simple Browser. Useful for quickly viewing locally hosted websites, demos, or resources without leaving the coding environment.",
        "userDescription": "%copilot.tools.openSimpleBrowser.description%",
        "toolReferenceName": "openSimpleBrowser",
        "legacyToolReferenceFullNames": ["openSimpleBrowser"],
        "tags": [],
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The website URL to preview or open in the Simple Browser inside the editor. Must be either an http or https URL"
            }
          },
          "required": ["url"]
        }
      },
      {
        "name": "copilot_replaceString",
        "toolReferenceName": "replaceString",
        "displayName": "%copilot.tools.replaceString.name%",
        "modelDescription": "This is a tool for making edits in an existing file in the workspace. For moving or renaming files, use run in terminal tool with the 'mv' command instead. For larger edits, split them into smaller edits and call the edit tool multiple times to ensure accuracy. Before editing, always ensure you have the context to understand the file's contents and context. To edit a file, provide: 1) filePath (absolute path), 2) oldString (MUST be the exact literal text to replace including all whitespace, indentation, newlines, and surrounding code etc), and 3) newString (MUST be the exact literal text to replace \\`oldString\\` with (also including all whitespace, indentation, newlines, and surrounding code etc.). Ensure the resulting code is correct and idiomatic.). Each use of this tool replaces exactly ONE occurrence of oldString.\n\nCRITICAL for \\`oldString\\`: Must uniquely identify the single instance to change. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string matches multiple locations, or does not match exactly, the tool will fail. Never use 'Lines 123-456 omitted' from summarized documents or ...existing code... comments in the oldString or newString.",
        "when": "!config.github.copilot.chat.disableReplaceTool",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "An absolute path to the file to edit."
            },
            "oldString": {
              "type": "string",
              "description": "The exact literal text to replace, preferably unescaped. For single replacements (default), include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. For multiple replacements, specify expected_replacements parameter. If this string is not the exact literal text (i.e. you escaped it) or does not match exactly, the tool will fail."
            },
            "newString": {
              "type": "string",
              "description": "The exact literal text to replace `old_string` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic."
            }
          },
          "required": ["filePath", "oldString", "newString"]
        }
      },
      {
        "name": "copilot_multiReplaceString",
        "toolReferenceName": "multiReplaceString",
        "displayName": "%copilot.tools.multiReplaceString.name%",
        "modelDescription": "This tool allows you to apply multiple replace_string_in_file operations in a single call, which is more efficient than calling replace_string_in_file multiple times. It takes an array of replacement operations and applies them sequentially. Each replacement operation has the same parameters as replace_string_in_file: filePath, oldString, newString, and explanation. This tool is ideal when you need to make multiple edits across different files or multiple edits in the same file. The tool will provide a summary of successful and failed operations.",
        "when": "!config.github.copilot.chat.disableReplaceTool",
        "inputSchema": {
          "type": "object",
          "properties": {
            "explanation": {
              "type": "string",
              "description": "A brief explanation of what the multi-replace operation will accomplish."
            },
            "replacements": {
              "type": "array",
              "description": "An array of replacement operations to apply sequentially.",
              "items": {
                "type": "object",
                "properties": {
                  "explanation": {
                    "type": "string",
                    "description": "A brief explanation of this specific replacement operation."
                  },
                  "filePath": {
                    "type": "string",
                    "description": "An absolute path to the file to edit."
                  },
                  "oldString": {
                    "type": "string",
                    "description": "The exact literal text to replace, preferably unescaped. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string is not the exact literal text or does not match exactly, this replacement will fail."
                  },
                  "newString": {
                    "type": "string",
                    "description": "The exact literal text to replace `oldString` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic."
                  }
                },
                "required": [
                  "explanation",
                  "filePath",
                  "oldString",
                  "newString"
                ]
              },
              "minItems": 1
            }
          },
          "required": ["explanation", "replacements"]
        }
      },
      {
        "name": "copilot_editNotebook",
        "toolReferenceName": "editNotebook",
        "icon": "$(pencil)",
        "displayName": "%copilot.tools.editNotebook.name%",
        "userDescription": "%copilot.tools.editNotebook.userDescription%",
        "modelDescription": "This is a tool for editing an existing Notebook file in the workspace. Generate the \"explanation\" property first.\nThe system is very smart and can understand how to apply your edits to the notebooks.\nWhen updating the content of an existing cell, ensure newCode preserves whitespace and indentation exactly and does NOT include any code markers such as (...existing code...).",
        "tags": ["enable_other_tool_copilot_getNotebookSummary"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "An absolute path to the notebook file to edit, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1."
            },
            "cellId": {
              "type": "string",
              "description": "Id of the cell that needs to be deleted or edited. Use the value `TOP`, `BOTTOM` when inserting a cell at the top or bottom of the notebook, else provide the id of the cell after which a new cell is to be inserted. Remember, if a cellId is provided and editType=insert, then a cell will be inserted after the cell with the provided cellId."
            },
            "newCode": {
              "anyOf": [
                {
                  "type": "string",
                  "description": "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags. Do NOT include code markers such as (...existing code...) to indicate existing code."
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "description": "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags"
                  }
                }
              ]
            },
            "language": {
              "type": "string",
              "description": "The language of the cell. `markdown`, `python`, `javascript`, `julia`, etc."
            },
            "editType": {
              "type": "string",
              "enum": ["insert", "delete", "edit"],
              "description": "The operation peformed on the cell, whether `insert`, `delete` or `edit`.\nUse the `editType` field to specify the operation: `insert` to add a new cell, `edit` to modify an existing cell's content, and `delete` to remove a cell."
            }
          },
          "required": ["filePath", "editType", "cellId"]
        }
      },
      {
        "name": "copilot_runNotebookCell",
        "displayName": "%copilot.tools.runNotebookCell.name%",
        "toolReferenceName": "runNotebookCell",
        "legacyToolReferenceFullNames": ["runNotebooks/runCell"],
        "icon": "$(play)",
        "modelDescription": "This is a tool for running a code cell in a notebook file directly in the notebook editor. The output from the execution will be returned. Code cells should be run as they are added or edited when working through a problem to bring the kernel state up to date and ensure the code executes successfully. Code cells are ready to run and don't require any pre-processing. If asked to run the first cell in a notebook, you should run the first code cell since markdown cells cannot be executed. NOTE: Avoid executing Markdown cells or providing Markdown cell IDs, as Markdown cells cannot be  executed.",
        "userDescription": "%copilot.tools.runNotebookCell.description%",
        "tags": ["enable_other_tool_copilot_getNotebookSummary"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
            },
            "reason": {
              "type": "string",
              "description": "An optional explanation of why the cell is being run. This will be shown to the user before the tool is run and is not necessary if it's self-explanatory."
            },
            "cellId": {
              "type": "string",
              "description": "The ID for the code cell to execute. Avoid providing markdown cell IDs as nothing will be executed."
            },
            "continueOnError": {
              "type": "boolean",
              "description": "Whether or not execution should continue for remaining cells if an error is encountered. Default to false unless instructed otherwise."
            }
          },
          "required": ["filePath", "cellId"]
        }
      },
      {
        "name": "copilot_getNotebookSummary",
        "toolReferenceName": "getNotebookSummary",
        "legacyToolReferenceFullNames": ["runNotebooks/getNotebookSummary"],
        "displayName": "Get the structure of a notebook",
        "modelDescription": "This is a tool returns the list of the Notebook cells along with the id, cell types, line ranges, language, execution information and output mime types for each cell. This is useful to get Cell Ids when executing a notebook or determine what cells have been executed and what order, or what cells have outputs. If required to read contents of a cell use this to determine the line range of a cells, and then use read_file tool to read a specific line range. Requery this tool if the contents of the notebook change.",
        "tags": [],
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
            }
          },
          "required": ["filePath"]
        }
      },
      {
        "name": "copilot_readNotebookCellOutput",
        "displayName": "%copilot.tools.getNotebookCellOutput.name%",
        "toolReferenceName": "readNotebookCellOutput",
        "legacyToolReferenceFullNames": ["runNotebooks/readNotebookCellOutput"],
        "icon": "$(notebook-render-output)",
        "modelDescription": "This tool will retrieve the output for a notebook cell from its most recent execution or restored from disk. The cell may have output even when it has not been run in the current kernel session. This tool has a higher token limit for output length than the runNotebookCell tool.",
        "userDescription": "%copilot.tools.getNotebookCellOutput.description%",
        "when": "userHasOpenedNotebook",
        "tags": [],
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
            },
            "cellId": {
              "type": "string",
              "description": "The ID of the cell for which output should be retrieved."
            }
          },
          "required": ["filePath", "cellId"]
        }
      },
      {
        "name": "copilot_fetchWebPage",
        "displayName": "%copilot.tools.fetchWebPage.name%",
        "toolReferenceName": "fetch",
        "legacyToolReferenceFullNames": ["fetch"],
        "when": "!isWeb",
        "icon": "$(globe)",
        "userDescription": "%copilot.tools.fetchWebPage.description%",
        "modelDescription": "Fetches the main content from a web page. This tool is useful for summarizing or analyzing the content of a webpage. You should use this tool when you think the user is looking for information from a specific webpage.",
        "tags": [],
        "inputSchema": {
          "type": "object",
          "properties": {
            "urls": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "An array of URLs to fetch content from."
            },
            "query": {
              "type": "string",
              "description": "The query to search for in the web page's content. This should be a clear and concise description of the content you want to find."
            }
          },
          "required": ["urls", "query"]
        }
      },
      {
        "name": "copilot_findTestFiles",
        "displayName": "%copilot.tools.findTestFiles.name%",
        "icon": "$(beaker)",
        "canBeReferencedInPrompt": false,
        "toolReferenceName": "findTestFiles",
        "userDescription": "%copilot.tools.findTestFiles.description%",
        "modelDescription": "For a source code file, find the file that contains the tests. For a test file find the file that contains the code under test.",
        "tags": [],
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePaths": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": ["filePaths"]
        }
      },
      {
        "name": "copilot_getDocInfo",
        "displayName": "%copilot.tools.getDocInfo.name%",
        "icon": "$(beaker)",
        "canBeReferencedInPrompt": false,
        "toolReferenceName": "docInfo",
        "userDescription": "%copilot.tools.getDocInfo.description%",
        "modelDescription": "Find information about how to document it a symbol like a class or function. This tool is useful for generating documentation comments for code symbols. You should use this tool when you think the user is looking for information about how to document a specific code symbol.",
        "tags": [],
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePaths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The file paths for which documentation information is needed."
            }
          },
          "required": ["filePaths"]
        }
      },
      {
        "name": "copilot_getSearchResults",
        "toolReferenceName": "searchResults",
        "displayName": "%github.copilot.tools.searchResults.name%",
        "icon": "$(search)",
        "userDescription": "%github.copilot.tools.searchResults.description%",
        "modelDescription": "The results from the search view"
      },
      {
        "name": "copilot_githubRepo",
        "toolReferenceName": "githubRepo",
        "legacyToolReferenceFullNames": ["githubRepo"],
        "displayName": "%github.copilot.tools.githubRepo.name%",
        "modelDescription": "Searches a GitHub repository for relevant source code snippets. Only use this tool if the user is very clearly asking for code snippets from a specific GitHub repository. Do not use this tool for Github repos that the user has open in their workspace.",
        "userDescription": "%github.copilot.tools.githubRepo.userDescription%",
        "icon": "$(repo)",
        "when": "!config.github.copilot.chat.githubMcpServer.enabled",
        "inputSchema": {
          "type": "object",
          "properties": {
            "repo": {
              "type": "string",
              "description": "The name of the Github repository to search for code in. Should must be formatted as '<owner>/<repo>'."
            },
            "query": {
              "type": "string",
              "description": "The query to search for repo. Should contain all relevant context."
            }
          },
          "required": ["repo", "query"]
        }
      },
      {
        "name": "copilot_toolReplay",
        "modelDescription": "Replays a tool call from a previous chat session.",
        "displayName": "tool replay",
        "when": "false",
        "inputSchema": {
          "type": "object",
          "properties": {
            "toolCallId": {
              "type": "string",
              "description": "the id of the tool original tool call"
            },
            "toolName": {
              "type": "string",
              "description": "the name of the tool being replayed"
            },
            "toolCallArgs": {
              "type": "object",
              "description": "the arguments of the tool call"
            }
          }
        }
      },
      {
        "name": "copilot_memory",
        "toolReferenceName": "memory",
        "displayName": "%copilot.tools.memory.name%",
        "userDescription": "%copilot.tools.memory.description%",
        "modelDescription": "Manage persistent memory across conversations. This tool allows you to create, view, update, and delete memory files that persist between chat sessions. Use this to remember important information about the user, their preferences, project context, or anything that should be recalled in future conversations. Available commands: view (list/read memories), create (new memory file), str_replace (edit content), insert (add content), delete (remove memory), rename (change filename).",
        "icon": "$(database)",
        "when": "config.github.copilot.chat.tools.memory.enabled",
        "canBeReferencedInPrompt": true,
        "tags": [],
        "inputSchema": {
          "type": "object",
          "properties": {
            "command": {
              "type": "string",
              "enum": [
                "view",
                "create",
                "str_replace",
                "insert",
                "delete",
                "rename"
              ],
              "description": "The memory operation to perform:\n- view: Show directory contents or file contents (optional line ranges)\n- create: Create or overwrite a file\n- str_replace: Replace text in a file\n- insert: Insert text at a specific line\n- delete: Delete a file or directory\n- rename: Rename or move a file or directory"
            },
            "path": {
              "type": "string",
              "description": "Path to the memory file or directory. Must start with /memories.\n- For view: /memories or /memories/file.md\n- For create/str_replace/insert/delete: /memories/file.md\n- Not used for rename (use old_path/new_path instead)"
            },
            "view_range": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "minItems": 2,
              "maxItems": 2,
              "description": "[view only] Optional line range [start, end] to view specific lines. Example: [1, 10]"
            },
            "file_text": {
              "type": "string",
              "description": "[create only] Content to write to the file. Required for create command."
            },
            "old_str": {
              "type": "string",
              "description": "[str_replace only] The exact literal text to find and replace. Must be unique in the file. Required for str_replace command."
            },
            "new_str": {
              "type": "string",
              "description": "[str_replace only] The exact literal text to replace old_str with. Can be empty string. Required for str_replace command."
            },
            "insert_line": {
              "type": "number",
              "description": "[insert only] Line number at which to insert text (0-indexed, 0 = before first line). Required for insert command."
            },
            "insert_text": {
              "type": "string",
              "description": "[insert only] Text to insert at the specified line. Required for insert command."
            },
            "old_path": {
              "type": "string",
              "description": "[rename only] Current path of the file or directory. Must start with /memories. Required for rename command."
            },
            "new_path": {
              "type": "string",
              "description": "[rename only] New path for the file or directory. Must start with /memories. Required for rename command."
            }
          },
          "required": ["command"]
        }
      },
      {
        "name": "copilot_editFiles",
        "modelDescription": "This is a placeholder tool, do not use",
        "userDescription": "Edit files",
        "icon": "$(pencil)",
        "displayName": "Edit Files",
        "toolReferenceName": "editFiles",
        "legacyToolReferenceFullNames": ["editFiles"]
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/github.vscode-pull-request-github-0.124.0",
    "publisher": "GitHub",
    "name": "vscode-pull-request-github",
    "displayName": "%displayName%",
    "version": "0.124.0",
    "package_json": "/home/kai/.vscode/extensions/github.vscode-pull-request-github-0.124.0/package.json",
    "tools": [
      {
        "name": "github-pull-request_copilot-coding-agent",
        "displayName": "%languageModelTools.github-pull-request_copilot-coding-agent.displayName%",
        "modelDescription": "Completes the provided task using an asynchronous coding agent. Use when the user wants copilot continue completing a task in the background or asynchronously. IMPORTANT: Use this tool LAST/FINAL when users mention '#github-pull-request_copilot-coding-agent' in their query. This indicates they want the task/job implemented by the remote coding agent after all other analysis, planning, and preparation is complete. Call this tool at the END to hand off the fully-scoped task to the asynchronous GitHub Copilot coding agent. The agent will create a new branch, implement the changes, and open a pull request. Always use this tool as the final step when the hashtag is mentioned, after completing any other necessary tools or analysis first.",
        "when": "config.githubPullRequests.codingAgent.enabled",
        "icon": "$(send-to-remote-agent)",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "copilotCodingAgent",
        "userDescription": "%languageModelTools.github-pull-request_copilot-coding-agent.userDescription%",
        "inputSchema": {
          "type": "object",
          "required": ["title", "body"],
          "properties": {
            "title": {
              "type": "string",
              "description": "The title of the issue. Populate from chat context."
            },
            "body": {
              "type": "string",
              "description": "The body/description of the issue. Populate from chat context."
            },
            "existingPullRequest": {
              "type": "number",
              "description": "The number of an existing pull request related to the current coding agent task. Look in the chat history for this number.  In the chat it may look like 'Coding agent will continue work in #17...'. In this example, you should return '17'."
            }
          }
        }
      },
      {
        "name": "github-pull-request_issue_fetch",
        "tags": ["github", "issues", "prs"],
        "toolReferenceName": "issue_fetch",
        "displayName": "%languageModelTools.github-pull-request_issue_fetch.displayName%",
        "modelDescription": "Get a GitHub issue/PR's details as a JSON object.",
        "icon": "$(info)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "repo": {
              "type": "object",
              "description": "The repository to get the issue/PR from.",
              "properties": {
                "owner": {
                  "type": "string",
                  "description": "The owner of the repository to get the issue/PR from."
                },
                "name": {
                  "type": "string",
                  "description": "The name of the repository to get the issue/PR from."
                }
              },
              "required": ["owner", "name"]
            },
            "issueNumber": {
              "type": "number",
              "description": "The number of the issue/PR to get."
            }
          },
          "required": ["issueNumber"]
        },
        "when": "config.githubPullRequests.experimental.chat"
      },
      {
        "name": "github-pull-request_notification_fetch",
        "tags": ["github", "notification"],
        "toolReferenceName": "notification_fetch",
        "displayName": "%languageModelTools.github-pull-request_notification_fetch.displayName%",
        "modelDescription": "Get a GitHub notification's details as a JSON object.",
        "icon": "$(info)",
        "canBeReferencedInPrompt": false,
        "inputSchema": {
          "type": "object",
          "properties": {
            "thread_id": {
              "type": "string",
              "description": "The notification thread id."
            }
          },
          "required": ["thread_id"]
        },
        "when": "config.githubPullRequests.experimental.chat"
      },
      {
        "name": "github-pull-request_issue_summarize",
        "tags": ["github", "issues", "prs"],
        "toolReferenceName": "issue_summarize",
        "displayName": "%languageModelTools.github-pull-request_issue_summarize.displayName%",
        "modelDescription": "Summarizes a GitHub issue or pull request. A summary is a great way to describe an issue or pull request.",
        "icon": "$(info)",
        "canBeReferencedInPrompt": false,
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "description": "The title of the issue/PR"
            },
            "body": {
              "type": "string",
              "description": "The body of the issue/PR"
            },
            "owner": {
              "type": "string",
              "description": "The owner of the repo in which the issue/PR is located"
            },
            "repo": {
              "type": "string",
              "description": "The repo in which the issue/PR is located"
            },
            "comments": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "body": {
                    "type": "string",
                    "description": "The comment body"
                  },
                  "author": {
                    "type": "string",
                    "description": "The author of the comment"
                  }
                }
              },
              "description": "The array of associated string comments"
            },
            "fileChanges": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "fileName": {
                    "type": "string",
                    "description": "The name of the file of the change"
                  },
                  "patch": {
                    "type": "string",
                    "description": "The patch of the change"
                  }
                }
              },
              "description": "For a PR, the array of associated file changes"
            }
          },
          "required": ["title", "body", "comments", "owner", "repo"]
        },
        "when": "config.githubPullRequests.experimental.chat"
      },
      {
        "name": "github-pull-request_notification_summarize",
        "tags": ["github", "notification"],
        "toolReferenceName": "notification_summarize",
        "displayName": "%languageModelTools.github-pull-request_notification_summarize.displayName%",
        "modelDescription": "Summarizes a GitHub notification. A summary is a great way to describe a notification.",
        "icon": "$(info)",
        "canBeReferencedInPrompt": false,
        "inputSchema": {
          "type": "object",
          "properties": {
            "lastReadAt": {
              "type": "string",
              "description": "The last read time of the notification."
            },
            "lastUpdatedAt": {
              "type": "string",
              "description": "The last updated time of the notification."
            },
            "unread": {
              "type": "boolean",
              "description": "Whether the notification is unread."
            },
            "title": {
              "type": "string",
              "description": "The title of the notification issue/PR"
            },
            "body": {
              "type": "string",
              "description": "The body of the notification issue/PR"
            },
            "owner": {
              "type": "string",
              "description": "The owner of the repo in which the issue/PR is located"
            },
            "repo": {
              "type": "string",
              "description": "The repo in which the issue/PR is located"
            },
            "comments": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "body": {
                    "type": "string",
                    "description": "The comment body"
                  },
                  "author": {
                    "type": "string",
                    "description": "The author of the comment"
                  }
                }
              },
              "description": "The array of unread comments under the issue/PR of the notification"
            },
            "threadId": {
              "type": "number",
              "description": "The thread id of the notification"
            },
            "notificationKey": {
              "type": "string",
              "description": "The key of the notification"
            },
            "itemNumber": {
              "type": "string",
              "description": "The number of the issue/PR in the notification"
            },
            "itemType": {
              "type": "string",
              "description": "The type of the item in the notification - whether it is an issue or a PR"
            },
            "fileChanges": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "fileName": {
                    "type": "string",
                    "description": "The name of the file of the change"
                  },
                  "patch": {
                    "type": "string",
                    "description": "The patch of the change"
                  }
                },
                "required": ["fileName", "patch"]
              },
              "description": "For a notification about a PR, the array of associated file changes"
            }
          },
          "required": [
            "title",
            "comments",
            "lastUpdatedAt",
            "unread",
            "threadId",
            "notificationKey",
            "owner",
            "repo",
            "itemNumber",
            "itemType"
          ]
        },
        "when": "config.githubPullRequests.experimental.chat"
      },
      {
        "name": "github-pull-request_suggest-fix",
        "tags": ["github", "issues"],
        "toolReferenceName": "suggest-fix",
        "displayName": "%languageModelTools.github-pull-request_suggest-fix.displayName%",
        "modelDescription": "Summarize and suggest a fix for a GitHub issue.",
        "icon": "$(info)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "repo": {
              "type": "object",
              "description": "The repository to get the issue from.",
              "properties": {
                "owner": {
                  "type": "string",
                  "description": "The owner of the repository to get the issue from."
                },
                "name": {
                  "type": "string",
                  "description": "The name of the repository to get the issue from."
                }
              },
              "required": ["owner", "name"]
            },
            "issueNumber": {
              "type": "number",
              "description": "The number of the issue to get."
            }
          },
          "required": ["issueNumber", "repo"]
        },
        "when": "config.githubPullRequests.experimental.chat"
      },
      {
        "name": "github-pull-request_formSearchQuery",
        "tags": ["github", "issues", "search", "query", "natural language"],
        "toolReferenceName": "searchSyntax",
        "displayName": "%languageModelTools.github-pull-request_formSearchQuery.displayName%",
        "modelDescription": "Converts natural language to a GitHub search query. Should ALWAYS be called before doing a search.",
        "icon": "$(search)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "repo": {
              "type": "object",
              "description": "The repository to get the issue from.",
              "properties": {
                "owner": {
                  "type": "string",
                  "description": "The owner of the repository to get the issue from."
                },
                "name": {
                  "type": "string",
                  "description": "The name of the repository to get the issue from."
                }
              },
              "required": ["owner", "name"]
            },
            "naturalLanguageString": {
              "type": "string",
              "description": "A plain text description of what the search should be."
            }
          },
          "required": ["naturalLanguageString"]
        },
        "when": "config.githubPullRequests.experimental.chat"
      },
      {
        "name": "github-pull-request_doSearch",
        "tags": ["github", "issues", "search"],
        "toolReferenceName": "doSearch",
        "displayName": "%languageModelTools.github-pull-request_doSearch.displayName%",
        "modelDescription": "Execute a GitHub search given a well formed GitHub search query. Call github-pull-request_formSearchQuery first to get good search syntax and pass the exact result in as the 'query'.",
        "icon": "$(search)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "repo": {
              "type": "object",
              "description": "The repository to get the issue from.",
              "properties": {
                "owner": {
                  "type": "string",
                  "description": "The owner of the repository to get the issue from."
                },
                "name": {
                  "type": "string",
                  "description": "The name of the repository to get the issue from."
                }
              },
              "required": ["owner", "name"]
            },
            "query": {
              "type": "string",
              "description": "A well formed GitHub search query using proper GitHub search syntax."
            }
          },
          "required": ["query", "repo"]
        },
        "when": "config.githubPullRequests.experimental.chat"
      },
      {
        "name": "github-pull-request_renderIssues",
        "tags": ["github", "issues", "render", "display"],
        "toolReferenceName": "renderIssues",
        "displayName": "%languageModelTools.github-pull-request_renderIssues.displayName%",
        "modelDescription": "Render issue items from an issue search in a markdown table. The markdown table will be displayed directly to the user by the tool. No further display should be done after this!",
        "icon": "$(paintcan)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "arrayOfIssues": {
              "type": "array",
              "description": "An array of GitHub Issues.",
              "items": {
                "type": "object",
                "properties": {
                  "title": {
                    "type": "string",
                    "description": "The title of the issue."
                  },
                  "number": {
                    "type": "number",
                    "description": "The number of the issue."
                  },
                  "url": {
                    "type": "string",
                    "description": "The URL of the issue."
                  },
                  "state": {
                    "type": "string",
                    "description": "The state of the issue (open/closed)."
                  },
                  "createdAt": {
                    "type": "string",
                    "description": "The creation date of the issue."
                  },
                  "updatedAt": {
                    "type": "string",
                    "description": "The last update date of the issue."
                  },
                  "closedAt": {
                    "type": "string",
                    "description": "The closing date of the issue."
                  },
                  "author": {
                    "type": "object",
                    "description": "The author of the issue.",
                    "properties": {
                      "login": {
                        "type": "string",
                        "description": "The login of the author."
                      },
                      "url": {
                        "type": "string",
                        "description": "The URL of the author's profile."
                      }
                    }
                  },
                  "labels": {
                    "type": "array",
                    "description": "The labels associated with the issue.",
                    "items": {
                      "type": "object",
                      "properties": {
                        "name": {
                          "type": "string",
                          "description": "The name of the label."
                        },
                        "color": {
                          "type": "string",
                          "description": "The color of the label."
                        }
                      }
                    }
                  },
                  "assignees": {
                    "type": "array",
                    "description": "The assignees of the issue.",
                    "items": {
                      "type": "object",
                      "properties": {
                        "login": {
                          "type": "string",
                          "description": "The login of the assignee."
                        },
                        "url": {
                          "type": "string",
                          "description": "The URL of the assignee's profile."
                        }
                      }
                    }
                  },
                  "commentCount": {
                    "type": "number",
                    "description": "The number of comments on the issue."
                  },
                  "reactionCount": {
                    "type": "number",
                    "description": "The number of reactions on the issue."
                  }
                },
                "required": [
                  "title",
                  "number",
                  "url",
                  "state",
                  "createdAt",
                  "author",
                  "commentCount",
                  "reactionCount"
                ]
              }
            },
            "totalIssues": {
              "type": "number",
              "description": "The total number of issues in the search."
            }
          },
          "required": ["arrayOfIssues", "totalIssues"]
        },
        "when": "config.githubPullRequests.experimental.chat"
      },
      {
        "name": "github-pull-request_activePullRequest",
        "tags": ["github", "pull request"],
        "toolReferenceName": "activePullRequest",
        "displayName": "%languageModelTools.github-pull-request_activePullRequest.displayName%",
        "modelDescription": "Get comprehensive information about the active GitHub pull request (PR). The active PR is the one that is currently checked out. This includes the PR title, full description, list of changed files, review comments, PR state, and status checks/CI results. For PRs created by Copilot, it also includes the session logs which indicate the development process and decisions made by the coding agent. When asked about the active or current pull request, do this first! Use this tool for any request related to \"current changes,\" \"pull request details,\" \"what changed,\" \"PR status,\" or similar queries even if the user does not explicitly mention \"pull request.\" When asked to use this tool, ALWAYS use it.",
        "icon": "$(git-pull-request)",
        "canBeReferencedInPrompt": true,
        "userDescription": "%languageModelTools.github-pull-request_activePullRequest.description%",
        "when": "config.githubPullRequests.experimental.chat"
      },
      {
        "name": "github-pull-request_openPullRequest",
        "tags": ["github", "pull request"],
        "toolReferenceName": "openPullRequest",
        "displayName": "%languageModelTools.github-pull-request_openPullRequest.displayName%",
        "modelDescription": "Get comprehensive information about the GitHub pull request (PR) which is currently visible, but not necessarily checked out. This includes the PR title, full description, list of changed files, review comments, PR state, and status checks/CI results. For PRs created by Copilot, it also includes the session logs which indicate the development process and decisions made by the coding agent. When asked about the currently open pull request, do this first! Use this tool for any request related to \"pull request details,\" \"what changed,\" \"PR status,\" or similar queries even if the user does not explicitly mention \"pull request.\" When asked to use this tool, ALWAYS use it.",
        "icon": "$(git-pull-request)",
        "canBeReferencedInPrompt": true,
        "userDescription": "%languageModelTools.github-pull-request_openPullRequest.description%",
        "when": "config.githubPullRequests.experimental.chat"
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/mermaidchart.vscode-mermaid-chart-2.5.6",
    "publisher": "MermaidChart",
    "name": "vscode-mermaid-chart",
    "displayName": "Mermaid Chart",
    "version": "2.5.6",
    "package_json": "/home/kai/.vscode/extensions/mermaidchart.vscode-mermaid-chart-2.5.6/package.json",
    "tools": [
      {
        "name": "get-syntax-docs-mermaid",
        "tags": [
          "mermaid",
          "documentation",
          "get_syntax_docs",
          "mermaid-docs",
          "validation",
          "syntax",
          "errors",
          "essential",
          "mandatory"
        ],
        "toolReferenceName": "get_syntax_docs",
        "displayName": "Get Syntax Documentation",
        "modelDescription": "ALWAYS use this tool Before creating, editing, or working with any Mermaid diagram. Get the syntax documentation for a specific diagram type.\n\nAvailable diagram types:\n- `architecture.md`: Cloud/CI/CD Architecture Diagram\n- `block.md`: Block Diagram\n- `c4.md`: C4 Diagram\n- `classDiagram.md`: Class Diagram\n- `entityRelationshipDiagram.md`: Entity Relationship Diagram\n- `flowchart.md`: Flowchart\n- `gantt.md`: Gantt Chart\n- `gitgraph.md`: Git Graph Diagram\n- `kanban.md`: Kanban Diagram\n- `mindmap.md`: Mindmap\n- `packet.md`: Packet Diagram\n- `pie.md`: Pie Chart\n- `quadrantChart.md`: Quadrant Chart\n- `requirementDiagram.md`: Requirement Diagram\n- `sankey.md`: Sankey Diagram\n- `sequenceDiagram.md`: Sequence Diagram\n- `stateDiagram.md`: State Diagram\n- `timeline.md`: Timeline\n- `userJourney.md`: User Journey Diagram\n- `xyChart.md`: XY Chart",
        "icon": "$(files)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "enum": [
                "architecture.md",
                "block.md",
                "c4.md",
                "classDiagram.md",
                "entityRelationshipDiagram.md",
                "flowchart.md",
                "gantt.md",
                "gitgraph.md",
                "kanban.md",
                "mindmap.md",
                "packet.md",
                "pie.md",
                "quadrantChart.md",
                "requirementDiagram.md",
                "sankey.md",
                "sequenceDiagram.md",
                "stateDiagram.md",
                "timeline.md",
                "userJourney.md",
                "xyChart.md"
              ],
              "description": "The filename of the diagram type.\n\nAvailable diagram types:\n- `architecture.md`: Cloud/CI/CD Architecture Diagram\n- `block.md`: Block Diagram\n- `c4.md`: C4 Diagram\n- `classDiagram.md`: Class Diagram\n- `entityRelationshipDiagram.md`: Entity Relationship Diagram\n- `flowchart.md`: Flowchart\n- `gantt.md`: Gantt Chart\n- `gitgraph.md`: Git Graph Diagram\n- `kanban.md`: Kanban Diagram\n- `mindmap.md`: Mindmap\n- `packet.md`: Packet Diagram\n- `pie.md`: Pie Chart\n- `quadrantChart.md`: Quadrant Chart\n- `requirementDiagram.md`: Requirement Diagram\n- `sankey.md`: Sankey Diagram\n- `sequenceDiagram.md`: Sequence Diagram\n- `stateDiagram.md`: State Diagram\n- `timeline.md`: Timeline\n- `userJourney.md`: User Journey Diagram\n- `xyChart.md`: XY Chart"
            }
          },
          "required": ["file"]
        }
      },
      {
        "name": "mermaid-diagram-validator",
        "tags": [
          "editing",
          "diagram",
          "mermaid",
          "before-preview",
          "before-visualization",
          "validation",
          "syntax",
          "errors",
          "essential",
          "mandatory",
          "pre-check",
          "check",
          "verify",
          "test",
          "debug"
        ],
        "displayName": "Mermaid Diagram Validator",
        "toolReferenceName": "mermaid-diagram-validator",
        "canBeReferencedInPrompt": true,
        "modelDescription": "Validate a Mermaid diagram. ALWAYS use this tool after when creating, editing, or working with any Mermaid diagram and before preview. The Mermaid Diagram Validator is an ESSENTIAL tool for ensuring the accuracy and correctness of Mermaid diagrams. It MUST be used IMMEDIATELY AFTER CREATING, EDITING, or WORKING WITH any Mermaid diagram or BEFORE PREVIEWING it. This tool is CRUCIAL for checking, verifying, testing, and debugging any Mermaid diagram code for syntax errors or formatting issues. It ensures that diagrams are correctly formatted and free of errors before they are rendered or visualized. This includes diagrams created from any source file, such as TypeScript, Java, or any other programming language. By using this tool, you can prevent errors and ensure that your diagrams are accurate and reliable. ALWAYS validate your diagrams to maintain high-quality visualizations and avoid potential issues during rendering.",
        "icon": "$(check)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "code": {
              "type": "string",
              "description": "The complete Mermaid diagram code to validate, including any YAML frontmatter blocks if present. This code should be thoroughly checked for any syntax errors or formatting issues to ensure it is ready for rendering."
            }
          },
          "required": ["code"]
        }
      },
      {
        "name": "mermaid-diagram-preview",
        "tags": [
          "editing",
          "diagram",
          "mermaid",
          "preview",
          "visualization",
          "essential",
          "mandatory",
          "show",
          "view"
        ],
        "displayName": "Mermaid Diagram Preview",
        "toolReferenceName": "mermaid-diagram-preview",
        "canBeReferencedInPrompt": true,
        "modelDescription": "Preview a Mermaid diagram. ALWAYS use this tool after validation when creating, editing, or working with any Mermaid diagram. The code paramter of this MUST CONTAIN ONLY the Mermaid code block without any surrounding or other content. IMPORTANT USAGE PATTERN: For EXISTING Mermaid diagram files, ALWAYS pass the documentUri parameter (NOT the code). Only use the code parameter for NEW diagrams that don't exist in files yet or when you've extracted ONLY the Mermaid code block from markdown. This tool renders and visualizes diagrams including flowcharts, sequence diagrams, class diagrams, ER diagrams, and other chart types. The diagram code should include any YAML frontmatter blocks (like id, title, config) if present.",
        "icon": "$(eye)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "documentUri": {
              "type": "string",
              "description": "PREFERRED: The URI of an existing document to preview. For existing files, ALWAYS use this parameter instead of extracting code from the file."
            },
            "code": {
              "type": "string",
              "description": "The complete Mermaid diagram code to preview. This MUST BE ONLY the Mermaid code block syntax without any surrounding content. ONLY use this parameter for NEW diagrams"
            },
            "showSource": {
              "type": "boolean",
              "description": "Whether to also open the source code in an editor",
              "default": true
            }
          }
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/ms-azure-load-testing.microsoft-testing-0.1.17",
    "publisher": "ms-azure-load-testing",
    "name": "microsoft-testing",
    "displayName": "Azure Load Testing",
    "version": "0.1.17",
    "package_json": "/home/kai/.vscode/extensions/ms-azure-load-testing.microsoft-testing-0.1.17/package.json",
    "tools": [
      {
        "name": "create_load_test_script",
        "tags": [
          "editors",
          "testing",
          "azure",
          "load-testing",
          "create-load-test-script"
        ],
        "toolReferenceName": "create_load_test_script",
        "displayName": "Create Load Test Script",
        "modelDescription": "Generates a load test script based on Locust or JMeter from a URL endpoint or an input file (Postman, Insomnia, or HTTP file). If the user does not provide required parameters (such as endpoint_url or input_file_path), the tool will interactively prompt the user for the missing information during execution, so still you can call this tool to generate script. Use this tool to quickly create a Locust script for load testing.",
        "userDescription": "Generate a load test script based on Locust or JMeter using a URL endpoint or an input file (Postman, Insomnia, or HTTP file). If you do not provide all required details, you can still execute this tool.",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "endpoint_url": {
              "type": "string",
              "description": "The target URL endpoint to load test (e.g., https://example.com). If not provided, you can still call this tool to generate a script."
            },
            "input_file_path": {
              "type": "string",
              "description": "The absolute path to the input file (Postman, Insomnia, or HTTP file) for REST APIs. If not provided, you can still call this tool to generate a script."
            },
            "virtual_user_count": {
              "type": "number",
              "description": "The number of virtual users to simulate (e.g., 50). If not provided, you can still call this tool to generate a script."
            },
            "test_duration_seconds": {
              "type": "string",
              "description": "The duration of the test in seconds (e.g., 120). If not provided, you can still call this tool to generate a script."
            },
            "input_file_type": {
              "type": "string",
              "description": "The type of input file (postman, insomnia, http). If not provided, you can still call this tool to generate a script."
            },
            "testType": {
              "type": "string",
              "description": "The type of test to generate (Locust, JMeter). If not provided, you can still call this tool to generate a script."
            }
          }
        }
      },
      {
        "name": "select_azure_load_testing_resource",
        "tags": [
          "editors",
          "testing",
          "azure",
          "load-testing",
          "select-resource"
        ],
        "toolReferenceName": "select_azure_load_testing_resource",
        "displayName": "Select Azure Load Testing Resource",
        "modelDescription": "Selects and returns the Azure Load Testing resource ID. If the user does not specify a resource, the tool will prompt the user to select one from available resources during execution. Use this tool to choose a resource for test execution and analysis.",
        "userDescription": "Select an Azure Load Testing resource to use for test execution and analysis. If you do not specify a resource, you will be prompted to select one.",
        "canBeReferencedInPrompt": true
      },
      {
        "name": "run_load_test_in_azure",
        "tags": [
          "editors",
          "testing",
          "azure",
          "load-testing",
          "run-load-test"
        ],
        "toolReferenceName": "run_load_test_in_azure",
        "displayName": "Run Load Test in Azure",
        "modelDescription": "Run a load test using Azure Load Testing. If a load test configuration file exists in the repository, it should be favored over providing a script path or manual parameters. If there is no configuration file, then a test script path needs to be provided. If there are no test scripts, then use the create_load_test_script tool to generate a script.",
        "userDescription": "Run a load test in Azure Load Testing using a script or configuration file. If you do not provide all required details, you can still call this tool.",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "script_file_path": {
              "type": "string",
              "description": "The absolute path to the Locust or JMeter load test script to run in Azure Load Testing. If not provided, you can still call this tool."
            },
            "azure_load_testing_resourceId": {
              "type": "string",
              "description": "The full Azure Load Testing resource ID (e.g., /subscriptions/000.../resourceGroups/myResourceGroup/providers/Microsoft.LoadTestService/loadTestResources/myLoadTestResource). If not provided, you can use tool select_azure_load_testing_resource to select a resource."
            },
            "virtual_user_count": {
              "type": "number",
              "description": "The number of virtual users to simulate (e.g., 50). If not provided, you can still call this tool."
            },
            "test_duration_seconds": {
              "type": "string",
              "description": "The duration of the test in seconds (e.g., 120). If not provided, you can still call this tool."
            },
            "configuration_file_path": {
              "type": "string",
              "description": "The absolute path to the load test configuration file to run in Azure Load Testing. If not provided, you can still call this tool."
            }
          }
        }
      },
      {
        "name": "select_azure_load_test_run",
        "tags": [
          "editors",
          "testing",
          "azure",
          "load-testing",
          "select-test-run"
        ],
        "toolReferenceName": "select_azure_load_test_run",
        "displayName": "Select Azure Load Test Run",
        "modelDescription": "Selects a specific test run from an Azure Load Testing resource. If the user does not specify a resource or test run, the tool will prompt the user to select from available options during execution. Use this tool to choose a test run for further analysis.",
        "userDescription": "Choose a specific load test run within an Azure Load Testing resource. If you do not specify a resource or test run, you will be prompted to select one.",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "azure_load_testing_resourceId": {
              "type": "string",
              "description": "The full Azure Load Testing resource ID to get insights from. If not provided, you can still call this tool to generate a script."
            }
          }
        }
      },
      {
        "name": "get_azure_load_test_run_insights",
        "tags": [
          "editors",
          "testing",
          "azure",
          "load-testing",
          "test-run-insights"
        ],
        "toolReferenceName": "get_azure_load_test_run_insights",
        "displayName": "Get Azure Load Test Run Insights",
        "modelDescription": "Retrieves performance and diagnostic insights from a specific Azure Load Testing run using its test run ID and resource ID. If any required parameters are missing, the tool will prompt the user to provide them during execution. Use this tool to analyze test results.",
        "userDescription": "Retrieve insights from a specific Azure Load Testing run. If you do not provide all required details, you will be prompted for them.",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "test_run_id": {
              "type": "string",
              "description": "The ID of the load test run to fetch insights for. If not provided, you can still call this tool to generate a script."
            },
            "azure_load_testing_resourceId": {
              "type": "string",
              "description": "The full Azure Load Testing resource ID to get insights from. If not provided, you can still call this tool to generate a script."
            }
          }
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/ms-azuretools.vscode-apimanagement-1.3.0",
    "publisher": "ms-azuretools",
    "name": "vscode-apimanagement",
    "displayName": "Azure API Management",
    "version": "1.3.0",
    "package_json": "/home/kai/.vscode/extensions/ms-azuretools.vscode-apimanagement-1.3.0/package.json",
    "tools": [
      {
        "name": "get-available-apim-policies",
        "tags": ["editors", "apim"],
        "toolReferenceName": "get-available-apim-policies",
        "displayName": "Get Available APIM Policies",
        "modelDescription": "Retrieve available APIM policies.",
        "userDescription": "Fetch the list of available policies in Azure API Management.",
        "canBeReferencedInPrompt": true,
        "icon": "$(files)",
        "inputSchema": {}
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/ms-azuretools.vscode-azure-github-copilot-1.0.153-linux-x64",
    "publisher": "ms-azuretools",
    "name": "vscode-azure-github-copilot",
    "displayName": "GitHub Copilot for Azure",
    "version": "1.0.153",
    "package_json": "/home/kai/.vscode/extensions/ms-azuretools.vscode-azure-github-copilot-1.0.153-linux-x64/package.json",
    "tools": [
      {
        "name": "azure_bicep-get_azure_verified_module",
        "tags": ["azure"],
        "displayName": "Get Bicep module from Azure Verified Module",
        "modelDescription": "This tools gets Bicep module code from Azure Verified Modules for a given resource type. If you are asked to generate Bicep code, call this function multiple times once for each resource type to search for available modules and prefer using the module instead of writing raw Bicep code. You must always use this tool to discover the Bicep module for every Bicep schema you get and always prefer using existing Bicep modules if there is one over writing raw Bicep code.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "resourceType": {
              "type": "string",
              "description": "Full type name of the resource"
            }
          },
          "required": ["resourceType"]
        },
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "azure_get_azure_verified_module",
        "when": "copilotforazure.enableAvmTool == true"
      },
      {
        "name": "azure_development-recommend_custom_modes",
        "tags": ["azure"],
        "displayName": "%languageModelTools.azure_development-recommend_custom_modes.displayName%",
        "modelDescription": "This tool captures user intent about Azure-related topics and recommends custom modes to enhance Azure workflows. Always invoke this tool once before doing anything related to Azure.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "intent": {
              "type": "string",
              "description": "A concise description of what the user wants to do that is related to Azure."
            }
          },
          "required": ["intent"]
        },
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "azure_recommend_custom_modes"
      },
      {
        "name": "azure_resources-query_azure_resource_graph",
        "tags": ["azure"],
        "displayName": "%languageModelTools.azure_resources-query_azure_resource_graph.displayName%",
        "modelDescription": "This tool queries Azure Resource Graph (ARG) for information about resources, subscriptions, subscriptionIds or resource groups, that the user has access to in Azure including any Azure resource types including Azure Functions, Azure App Service, virtual machines, Azure Cache for Redis, virtual networks (VNET), etc. This tool should be used to obtain details about the user's resources (such as resource ids, status, os type, disk type, SKU, size, etc.), subscriptions (such as subscription id, subscription name, etc.) or resource groups (such as resource group id, name, etc...). If the user is asking about **THEIR RESOURCES** then this tool **IS** appropriate. This tool should not be used to generally learn about Azure resources. If the user is asking **CONCEPTUAL QUESTIONS** about Azure resources, this tool **IS NOT** appropriate.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "arg_intent": {
              "type": "string",
              "description": "A natural language description of the intent of the query to Azure Resource Graph. For instance *return the subscriptionId of Azure resource Squid*"
            },
            "useDefaultSubscriptionFilter": {
              "type": "boolean",
              "description": "If the user asks for information about resources in a specific subscription, or asks for information about resources across all subscriptions, this should be false. Otherwise, it should be true."
            }
          },
          "required": ["arg_intent", "useDefaultSubscriptionFilter"]
        },
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "azure_query_azure_resource_graph"
      },
      {
        "name": "azure_auth-get_auth_context",
        "tags": ["azure"],
        "displayName": "%languageModelTools.azure_auth-get_auth_context.displayName%",
        "modelDescription": "This tool gets the full Azure authentication context that will be used by Azure related tools for the Agent. Use this tool to inform the user when they asked for such information or when they express that the authentication context being used is incorrect.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        },
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "azure_get_auth_context"
      },
      {
        "name": "azure_auth-set_auth_context",
        "tags": ["azure"],
        "displayName": "%languageModelTools.azure_auth-set_auth_context.displayName%",
        "modelDescription": "This tool modifies the Azure authentication context. Azure authentication context is used by the Azure related tools for the Agent. Use this tool when the user expresses the intent to update the Azure authentication context to use. You may suggest this tool if it can be inferred from the conversation that the current Azure authentication context is incorrect",
        "inputSchema": {
          "type": "object",
          "properties": {
            "operation": {
              "type": "string",
              "description": "The operation to take to update the auth context. Possible values are 'wizard', 'set-tenant', 'select-subscription' and 'sign-out'. Prefer using 'wizard' by default which will guide user through all the steps to set the auth context. Use 'set-tenant', 'select-subscription' or 'sign-out' when the user explicitly said they want to do so."
            },
            "tenantIdOrName": {
              "type": "string",
              "description": "The ID or name of the tenant to set as the current tenant. This parameter is only required when the operation is 'set-tenant'."
            }
          }
        },
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "azure_set_auth_context"
      },
      {
        "name": "azure_dotnet_templates-get_tags",
        "tags": ["azure"],
        "displayName": "%languageModelTools.azure_dotnet_templates-get_tags.displayName%",
        "modelDescription": "Retrieves the list of tags that can be used to filter the available dotnet templates. Call this when the user needs help finding a template for a dotnet project, or before generating a `dotnet new` command to create a project. Pick the tag that best matches the user's intent, then call 'azure_dotnet_templates-get_templates_for_tag' to get the templates matching that tag. Returns a list of available tags that can be used to filter the templates.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        },
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "azure_get_dotnet_template_tags"
      },
      {
        "name": "azure_dotnet_templates-get_templates_for_tag",
        "tags": ["azure"],
        "displayName": "%languageModelTools.azure_dotnet_templates-get_templates_for_tag.displayName%",
        "modelDescription": "Retrieves the list of dotnet project templates available for `dotnet new` commands that match the given tag. Call this when the user needs help finding a template for a dotnet project, or before generating a `dotnet new` command to create a project. Use the names and descriptions of the templates to decide which is the best given the context. Returns a list of available templates, including the short name, full name, and a description.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tag": {
              "type": "string",
              "description": "The tag to filter the templates."
            }
          },
          "required": ["tag"]
        },
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "azure_get_dotnet_templates_for_tag"
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/ms-azuretools.vscode-azureresourcegroups-0.11.7",
    "publisher": "ms-azuretools",
    "name": "vscode-azureresourcegroups",
    "displayName": "Azure Resources",
    "version": "0.11.7",
    "package_json": "/home/kai/.vscode/extensions/ms-azuretools.vscode-azureresourcegroups-0.11.7/package.json",
    "tools": [
      {
        "displayName": "Azure Resources: Get Azure Activity Log",
        "icon": "$(azure)",
        "inputSchema": {},
        "modelDescription": "Gets the Azure activity log",
        "name": "azureResources_getAzureActivityLog",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "azureActivityLog",
        "tags": ["azure"]
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/ms-dynamics-smb.al-17.0.1869541",
    "publisher": "ms-dynamics-smb",
    "name": "al",
    "displayName": "AL Language extension for Microsoft Dynamics 365 Business Central",
    "version": "17.0.1869541",
    "package_json": "/home/kai/.vscode/extensions/ms-dynamics-smb.al-17.0.1869541/package.json",
    "tools": [
      {
        "name": "al_build",
        "displayName": "Build AL Project",
        "toolReferenceName": "al_build",
        "tags": ["editors", "build"],
        "modelDescription": "Builds the current AL project with a single command. The AL compiler checks for errors and warnings, ensuring your code is correct and up to date, and then generates a deployable .app file. Agents should use this tool to quickly validate and package AL projects, streamlining the development workflow and reducing manual steps.",
        "userDescription": "Build the current AL project.",
        "icon": "$(package)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_downloadsymbols",
        "tags": ["downloadsymbols"],
        "toolReferenceName": "al_download_symbols",
        "displayName": "Download AL Symbols",
        "modelDescription": "Automatically downloads all dependent symbols required by the current AL project. This ensures your project has access to the latest symbols from referenced apps and the platform, enabling accurate IntelliSense, validation, and builds. Agents should use this tool to keep dependencies up to date and avoid missing symbol errors during development. System symbols are downloaded automatically if platform and application exist in the app.json file.",
        "userDescription": "Download Symbols for the current AL project.",
        "icon": "$(file-symlink-file)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_getpackagedependencies",
        "displayName": "Get AL Package Dependencies",
        "toolReferenceName": "al_get_package_dependencies",
        "tags": ["symbols", "dependencies"],
        "modelDescription": "Automatically retrieves all dependent apps required by the current AL project or a specified package. This ensures your project has access to the latest symbols from referenced apps and the platform, enabling accurate IntelliSense, validation, and builds. Agents should use this tool to keep dependencies up to date and avoid missing symbol errors during development.",
        "userDescription": "Get Package Dependencies for an AL package.",
        "icon": "$(type-hierarchy-sub)",
        "canBeReferencedInPrompt": false,
        "inputSchema": {
          "type": "object",
          "properties": {
            "packageName": {
              "type": "string",
              "description": "Package Name to return dependencies for - example 'MyGreatApp'. If not provided, dependencies for the current project will be returned."
            }
          }
        }
      },
      {
        "name": "al_downloadsource",
        "displayName": "Download Source",
        "toolReferenceName": "al_download_source",
        "tags": ["source", "download"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Invokes the extension command to download AL source code for the workspace from the Business Central environment set in your launch.json, returning success or failure.",
        "userDescription": "Download source code for the current AL project (wrapper around AL: Download Source).",
        "icon": "$(cloud-download)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_clearcredentialscache",
        "displayName": "Clear Credentials Cache",
        "toolReferenceName": "al_clear_credentials_cache",
        "tags": ["auth", "cache"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Clears cached authentication credentials via the AL extension command.",
        "userDescription": "Clear cached authentication credentials (wrapper around AL: Clear credentials cache).",
        "icon": "$(trash)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_insertevent",
        "displayName": "Insert Event",
        "toolReferenceName": "al_insert_event",
        "tags": ["events", "code"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Inserts an event subscriber or publisher via the AL extension command.",
        "userDescription": "Insert an AL event (wrapper around AL: Find Event / Insert Event).",
        "icon": "$(symbol-event)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_clearprofilecodelenses",
        "displayName": "Clear Profile Code Lenses",
        "toolReferenceName": "al_clear_profile_codelenses",
        "tags": ["profile", "maintenance"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Clears profile code lenses in the current AL workspace.",
        "userDescription": "Clear profile code lenses (wrapper around AL: Clear Profile Code Lenses).",
        "icon": "$(eye-closed)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_initalizesnapshotdebugging",
        "displayName": "Initialize Snapshot Debugging",
        "toolReferenceName": "al_initalize_snapshot_debugging",
        "tags": ["snapshot", "debug"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Initializes a snapshot debugging session via the AL extension command.",
        "userDescription": "Initialize a snapshot debugging session (wrapper around AL: Initialize snapshot debugging).",
        "icon": "$(debug-start)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_finishsnapshotdebugging",
        "displayName": "Finish Snapshot Debugging",
        "toolReferenceName": "al_finish_snapshot_debugging",
        "tags": ["snapshot", "debug"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Finishes an active snapshot debugging session via the AL extension command.",
        "userDescription": "Finish the current snapshot debugging session (wrapper around AL: Finish snapshot debugging).",
        "icon": "$(debug-stop)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_go",
        "displayName": "Go (Navigate / Initialize)",
        "toolReferenceName": "al_go",
        "tags": ["project", "navigation"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Executes the AL: Go! command to initialize an AL project. This command is used to start a new AL project.",
        "userDescription": "Run the AL: Go! command (initialize a project).",
        "icon": "$(rocket)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_newproject",
        "displayName": "New AL Project",
        "toolReferenceName": "al_new_project",
        "tags": ["project", "scaffold"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Creates a new AL project using the AL: New Project command.",
        "userDescription": "Create a new AL project.",
        "icon": "$(new-file)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_incrementalpublish",
        "displayName": "Incremental Publish",
        "toolReferenceName": "al_incremental_publish",
        "tags": ["publish", "deployment"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Performs a rapid application publish with debugging. By enabling delta compilation, RAD allows developers to focus on changes made to application objects, reducing build and publish times for large projects. (wrapper around AL: Rapid Application Publish with debugging).",
        "userDescription": "Incrementally publish the current AL project with debugging enabled.",
        "icon": "$(cloud-upload)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_debugWithoutpublish",
        "displayName": "Debug Without Publish",
        "toolReferenceName": "al_debug_without_publish",
        "tags": ["debug", "run"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Starts a debug session without publishing (wrapper around AL: Debug without publishing).",
        "userDescription": "Start a debug session without publishing the extension.",
        "icon": "$(debug-alt)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_buildall",
        "displayName": "Build All Projects",
        "toolReferenceName": "al_build_all",
        "tags": [
          "build",
          "compile",
          "package",
          "dependencies",
          "workspace",
          "all",
          "tree"
        ],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Builds all AL projects in the workspace including the complete dependency tree. This command builds not just the active project but all dependent projects as well, ensuring the entire solution is compiled together. Use this when you need to build the complete workspace or when working with multi-project solutions. The tool automatically attempts to download required Business Central system symbols before building. Agents should use this for comprehensive workspace builds that include all dependencies.",
        "userDescription": "Build all AL projects in the workspace including dependencies. Use this to build the entire solution with its full dependency tree.",
        "icon": "$(package)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_generatecpuprofilefile",
        "displayName": "Generate CPU Profile File",
        "toolReferenceName": "al_generate_cpu_profile_file",
        "tags": ["profile", "performance"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Generates a CPU profile file for performance analysis.",
        "userDescription": "Generate a CPU profile file (wrapper around AL: Generate profile file).",
        "icon": "$(pulse)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_generatemanifest",
        "displayName": "Generate Manifest",
        "toolReferenceName": "al_generate_manifest",
        "tags": ["manifest", "metadata"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Generates a manifest file for the current AL project.",
        "userDescription": "Generate a manifest file (wrapper around AL: Generate manifest).",
        "icon": "$(file-code)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_generatepermissionsetforextensionobjects",
        "displayName": "Generate Permission Set (Extension Objects)",
        "toolReferenceName": "al_generate_permission_set_for_extension_objects",
        "tags": ["permissions", "security"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Generates a permission set AL object for current extension objects.",
        "userDescription": "Generate a permission set AL object containing current extension objects (wrapper around AL: Generate permission set as AL object).",
        "icon": "$(shield)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_generatepermissionsetforextensionobjectsasxml",
        "displayName": "Generate Permission Set XML (Extension Objects)",
        "toolReferenceName": "al_generate_permission_set_for_extension_objects_as_xml",
        "tags": ["permissions", "security"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Generates a permission set XML file for current extension objects.",
        "userDescription": "Generate a permission set XML file containing current extension objects (wrapper around AL: Generate permission set as XML).",
        "icon": "$(shield)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_openeventrecorder",
        "displayName": "Open Event Recorder",
        "toolReferenceName": "al_open_event_recorder",
        "tags": ["events", "diagnostics"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Opens the AL Event Recorder UI (wrapper around AL: Open Event Recorder).",
        "userDescription": "Open the AL Event Recorder interface to capture runtime events.",
        "icon": "$(record)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_openPageDesigner",
        "displayName": "Open Page Designer",
        "toolReferenceName": "al_open_page_designer",
        "tags": ["design", "ui"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Opens the AL Page Designer (wrapper around AL: Open Page Designer).",
        "userDescription": "Open the AL Page Designer interface for the current page context.",
        "icon": "$(layout)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_package",
        "displayName": "Package AL Project",
        "toolReferenceName": "al_package",
        "tags": ["package", "build"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Packages the AL project (wrapper around AL: Package).",
        "userDescription": "Create an app package for the current AL project.",
        "icon": "$(archive)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_publish",
        "displayName": "Publish AL Package",
        "toolReferenceName": "al_publish",
        "tags": ["publish", "deployment"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Publishes the built AL package to the target environment (wrapper around AL: Publish).",
        "userDescription": "Publish the AL package to the configured Business Central environment.",
        "icon": "$(cloud-upload)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_publishwithoutdebug",
        "displayName": "Publish AL Package (No Debug)",
        "toolReferenceName": "al_publish_without_debug",
        "tags": ["publish", "deployment"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Publishes the AL package without starting a debug session (wrapper around AL: Publish without debugging).",
        "userDescription": "Publish the AL package without initiating a debug session.",
        "icon": "$(cloud-upload)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_publishexistingextension",
        "displayName": "Publish Existing Extension",
        "toolReferenceName": "al_publish_existing_extension",
        "tags": ["publish", "deployment"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Publishes an already packaged existing extension and starts debugging (wrapper around AL: Publish Existing Extension).",
        "userDescription": "Publish an existing packaged AL extension to the target environment with debugging.",
        "icon": "$(cloud-upload)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "al_viewsnapshots",
        "displayName": "Open Snapshots",
        "toolReferenceName": "al_view_snapshots",
        "tags": ["debug", "snapshot"],
        "modelDescription": "Inputs: none. Outputs: { success: boolean, error?: string }. Opens the snapshots view (wrapper around AL: Snapshots).",
        "userDescription": "Open the AL snapshots interface.",
        "icon": "$(history)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/ms-mssql.mssql-1.37.1",
    "publisher": "ms-mssql",
    "name": "mssql",
    "displayName": "SQL Server (mssql)",
    "version": "1.37.1",
    "package_json": "/home/kai/.vscode/extensions/ms-mssql.mssql-1.37.1/package.json",
    "tools": [
      {
        "name": "mssql_show_schema",
        "modelDescription": "Open an interactive schema designer for a MSSQL database. This tool takes a connection ID as input and opens a graphical view of the database schema, including tables and relationships.",
        "tags": ["databases", "mssql", "schema", "visualization"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "description": "Connection ID to use for schema visualization.",
              "title": "Connection ID",
              "type": "string"
            }
          },
          "required": ["connectionId"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "Show Database Schema",
        "toolReferenceName": "mssql_show_schema",
        "userDescription": "Show database schema for a connected MSSQL database.",
        "icon": "$(graph-scatter)"
      },
      {
        "name": "mssql_connect",
        "modelDescription": "Connect to an MSSQL database server using a server name, an optional database name, and an optional profileId. The server name must be retrieved from mssql_list_servers. The profileId should be used ONLY when the user explicitly mentions a profile name, profile ID, or wants to connect 'using profile X'. Returns a connection ID that is used to interact with the database with other mssql tools. If a specific database is given and the connection fails, use mssql_list_databases against a connection to the default database to find the correct database name. The connection ID is a UUID.",
        "tags": ["databases", "mssql", "connection"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "serverName": {
              "description": "Server name to connect to. Should be validated with mssql_list_servers.",
              "title": "Server Name",
              "type": "string"
            },
            "database": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Optional database name to connect to. If omitted, uses the server's default database.",
              "title": "Database Name"
            },
            "profileId": {
              "description": "ID of a saved connection profile to use for connecting. Use ONLY when the user explicitly mentions a profile name, profile ID, or wants to connect 'using profile X'.",
              "title": "Profile ID",
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "required": ["serverName"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "Connect to MSSQL Server or Database",
        "toolReferenceName": "mssql_connect",
        "userDescription": "Connect to a MSSQL server or database.",
        "icon": "$(plug)"
      },
      {
        "name": "mssql_disconnect",
        "modelDescription": "Disconnect from a server or specific database. Returns a success message.",
        "tags": ["databases", "mssql", "disconnection"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "description": "Connection ID to disconnect.",
              "title": "Connection ID",
              "type": "string"
            }
          },
          "required": ["connectionId"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "Disconnect from MSSQL Server or Database",
        "toolReferenceName": "mssql_disconnect",
        "userDescription": "Disconnect from a MSSQL server or database.",
        "icon": "$(debug-disconnect)"
      },
      {
        "name": "mssql_list_servers",
        "modelDescription": "List all available MSSQL servers. Returns a list of server names.",
        "tags": ["databases", "mssql", "server", "list"],
        "canBeReferencedInPrompt": true,
        "displayName": "List MSSQL Servers",
        "toolReferenceName": "mssql_list_servers",
        "userDescription": "List all available MSSQL servers.",
        "icon": "$(server)"
      },
      {
        "name": "mssql_list_databases",
        "modelDescription": "List all available databases for a connected MSSQL server. Returns a list of database names.",
        "tags": ["databases", "mssql", "list"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "description": "Connection ID to list databases for.",
              "title": "Connection ID",
              "type": "string"
            }
          },
          "required": ["connectionId"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "List MSSQL Databases",
        "toolReferenceName": "mssql_list_databases",
        "userDescription": "List all available databases for a connected MSSQL server.",
        "icon": "$(database)"
      },
      {
        "name": "mssql_get_connection_details",
        "modelDescription": "Get connection details for a specific connection ID. Returns connection information including server, database, authentication type, and user details.",
        "tags": ["databases", "mssql", "connection", "details"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "description": "Connection ID to get details for.",
              "title": "Connection ID",
              "type": "string"
            }
          },
          "required": ["connectionId"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "Get MSSQL Connection Details",
        "toolReferenceName": "mssql_get_connection_details",
        "userDescription": "Get connection details for a specific MSSQL connection.",
        "icon": "$(info)"
      },
      {
        "name": "mssql_change_database",
        "modelDescription": "Change the database for an existing MSSQL connection. Before changing, consider using mssql_list_databases to show available database options to the user. Disconnects from current database and reconnects to the specified database using the same connection credentials.",
        "tags": ["databases", "mssql", "connection", "change"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "description": "Connection ID to change database for.",
              "title": "Connection ID",
              "type": "string"
            },
            "database": {
              "description": "Database name to switch to.",
              "title": "Database Name",
              "type": "string"
            }
          },
          "required": ["connectionId", "database"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "Change MSSQL Database",
        "toolReferenceName": "mssql_change_database",
        "userDescription": "Change the database for an existing MSSQL connection.",
        "icon": "$(arrow-swap)"
      },
      {
        "name": "mssql_list_tables",
        "modelDescription": "List all tables in a specific database for a connected MSSQL server. Returns a list of table names with schema information.",
        "tags": ["databases", "mssql", "tables", "list"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "description": "Connection ID to list tables for.",
              "title": "Connection ID",
              "type": "string"
            }
          },
          "required": ["connectionId"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "List MSSQL Tables",
        "toolReferenceName": "mssql_list_tables",
        "userDescription": "List all tables in a database for a connected MSSQL server."
      },
      {
        "name": "mssql_list_schemas",
        "modelDescription": "List all schemas in a specific database for a connected MSSQL server. Returns a list of schema names.",
        "tags": ["databases", "mssql", "schemas", "list"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "description": "Connection ID to list schemas for.",
              "title": "Connection ID",
              "type": "string"
            }
          },
          "required": ["connectionId"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "List MSSQL Schemas",
        "toolReferenceName": "mssql_list_schemas",
        "userDescription": "List all schemas in a database for a connected MSSQL server.",
        "icon": "$(symbol-namespace)"
      },
      {
        "name": "mssql_list_views",
        "modelDescription": "List all views in a specific database for a connected MSSQL server. Returns a list of view names with schema information.",
        "tags": ["databases", "mssql", "views", "list"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "description": "Connection ID to list views for.",
              "title": "Connection ID",
              "type": "string"
            }
          },
          "required": ["connectionId"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "List MSSQL Views",
        "toolReferenceName": "mssql_list_views",
        "userDescription": "List all views in a database for a connected MSSQL server.",
        "icon": "$(eye)"
      },
      {
        "name": "mssql_list_functions",
        "modelDescription": "List all functions in a specific database for a connected MSSQL server. Returns a list of function names with schema information.",
        "tags": ["databases", "mssql", "functions", "list"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "description": "Connection ID to list functions for.",
              "title": "Connection ID",
              "type": "string"
            }
          },
          "required": ["connectionId"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "List MSSQL Functions",
        "toolReferenceName": "mssql_list_functions",
        "userDescription": "List all functions in a database for a connected MSSQL server.",
        "icon": "$(symbol-function)"
      },
      {
        "name": "mssql_run_query",
        "modelDescription": "Execute a SQL query against a connected MSSQL database. Returns query results including row count, column information, and data rows. Use this tool to run SELECT, INSERT, UPDATE, DELETE, or other SQL statements. IMPORTANT: This tool will execute ANY SQL statement provided - be extremely careful with write operations (INSERT, UPDATE, DELETE, CREATE, ALTER, DROP) as they will modify or destroy data. Always verify the query is safe before execution, especially for operations without WHERE clauses or that affect system objects.",
        "tags": ["databases", "mssql", "query", "execute", "sql"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "description": "Connection ID to execute the query against.",
              "title": "Connection ID",
              "type": "string"
            },
            "query": {
              "description": "SQL query to execute.",
              "title": "SQL Query",
              "type": "string"
            },
            "queryTypes": {
              "description": "Classification of SQL operation types present in the query. Used for telemetry to understand tool usage patterns without capturing user content. Analyze the query and select all operation types that apply.",
              "title": "Query Types",
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "SELECT",
                  "INSERT",
                  "UPDATE",
                  "DELETE",
                  "CREATE",
                  "ALTER",
                  "DROP",
                  "TRUNCATE",
                  "MERGE",
                  "JOIN",
                  "CTE",
                  "STORED_PROCEDURE",
                  "FUNCTION",
                  "VIEW",
                  "INDEX",
                  "TRANSACTION",
                  "GRANT",
                  "REVOKE",
                  "BACKUP",
                  "RESTORE",
                  "EXEC",
                  "DECLARE",
                  "IF",
                  "WHILE",
                  "TRY_CATCH",
                  "TEMP_TABLE",
                  "CONSTRAINT",
                  "TRIGGER",
                  "SET",
                  "OTHER"
                ]
              }
            },
            "queryIntent": {
              "description": "Primary use case or scenario that best describes what the user is trying to accomplish with this query. Used for telemetry to understand user workflows without capturing user content.",
              "title": "Query Intent",
              "type": "string",
              "enum": [
                "data_exploration",
                "data_analysis",
                "data_migration",
                "troubleshooting",
                "schema_creation",
                "schema_modification",
                "schema_exploration",
                "data_maintenance",
                "data_seeding",
                "testing_validation",
                "backup_restore",
                "performance_tuning",
                "learning_education",
                "other"
              ]
            }
          },
          "required": ["connectionId", "query", "queryTypes", "queryIntent"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "Run MSSQL Query",
        "toolReferenceName": "mssql_run_query",
        "userDescription": "Execute a SQL query against a connected MSSQL database.",
        "icon": "$(play)"
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/ms-ossdata.vscode-pgsql-1.12.0-linux-x64",
    "publisher": "ms-ossdata",
    "name": "vscode-pgsql",
    "displayName": "PostgreSQL",
    "version": "1.12.0",
    "package_json": "/home/kai/.vscode/extensions/ms-ossdata.vscode-pgsql-1.12.0-linux-x64/package.json",
    "tools": [
      {
        "name": "pgsql_list_servers",
        "modelDescription": "List all database servers registered with the PGSQL extension. Returns a list of objects with the server name, host name, and default database.",
        "tags": ["databases", "postgresql", "pgsql"],
        "canBeReferencedInPrompt": true,
        "displayName": "List Servers",
        "toolReferenceName": "pgsql_listServers",
        "userDescription": "List all database servers registered with the PGSQL extension.",
        "icon": "$(server)"
      },
      {
        "name": "pgsql_connect",
        "modelDescription": "Connect to a PostgreSQL database server using a server name and optional database name. The server name is retrieved from pgsql_listServers. Returns a connection ID that is used to interact with the database with other pgsql tools. If a specific database is given and the connection fails, use $pgsql_list_databases against a connection to the default database to find the correct database name. The connection ID is a string formatted as 'pgsql/{server name}[/{database name}]', where if no database name is present it's the default database for the server.",
        "tags": ["databases", "postgresql", "pgsql"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "serverName": {
              "description": "Server name. Ensure this is validated with a call to pgsql_list_servers.",
              "title": "Server Name",
              "type": "string"
            },
            "database": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Optional database name; if omitted, uses the server's default database.",
              "title": "Database Name"
            }
          },
          "required": ["serverName"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "Connect to PostgreSQL Database",
        "toolReferenceName": "pgsql_connect",
        "userDescription": "Connect to a PostgreSQL server.",
        "icon": "$(plug)"
      },
      {
        "name": "pgsql_disconnect",
        "modelDescription": "Disconnect from a PostgreSQL database server using a connection ID. ",
        "tags": ["databases", "postgresql", "pgsql"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "description": "Connection ID to disconnect.",
              "title": "Connection ID",
              "type": "string"
            }
          },
          "required": ["connectionId"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "Disconnect from PostgreSQL Database",
        "toolReferenceName": "pgsql_disconnect",
        "userDescription": "Disconnect from a PostgreSQL server.",
        "icon": "$(debug-disconnect)"
      },
      {
        "name": "pgsql_open_script",
        "modelDescription": "Open a multiline SQL script in an untitled editor connected to a PostgreSQL connection. Prefer pgsql_query and pgsql_modify for single statements; use this tool for larger, multi-statement scripts, batch operations, or when the user must review and run code manually.",
        "tags": ["databases", "postgresql", "pgsql", "script", "batch"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "description": "Connection ID to use for the new script editor. Must come from pgsql_connect.",
              "title": "Connection ID",
              "type": "string"
            },
            "script": {
              "description": "The SQL script to open, formatted with line breaks and tabs; include comments to explain each section. Ideal for multi-statement batch scripts, maintenance tasks, or any scenario requiring user review before execution. Ensure the script is well-structured and easy to read, as it will be presented to the user for review. The script should be heavily commented and use best practices to ensure safe, secure, and efficient execution.",
              "title": "SQL Script",
              "type": "string"
            }
          },
          "required": ["connectionId", "script"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "Open SQL Script",
        "toolReferenceName": "pgsql_open_script",
        "userDescription": "Open an new SQL script editor with script content generated by agents.",
        "icon": "$(new-file)"
      },
      {
        "name": "pgsql_visualize_schema",
        "modelDescription": "Open an interactive visualization of the schema for a PostgreSQL database connection. Requires a connectionId from pgsql_connect. This tool opens a graphical view of the database schema, including tables and relationships.",
        "tags": ["databases", "postgresql", "pgsql", "schema", "visualization"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "description": "Connection ID to use for schema visualization.",
              "title": "Connection ID",
              "type": "string"
            }
          },
          "required": ["connectionId"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "Visualize Database Schema",
        "toolReferenceName": "pgsql_visualizeSchema",
        "userDescription": "Visualize the schema for a connected PostgreSQL database.",
        "icon": "$(graph-scatter)"
      },
      {
        "name": "pgsql_query",
        "modelDescription": "Run a formatted SQL query against a database. Requires a connectionId from the return value of pgsql_connect. This query must not modify the database at all. Can include SELECT, SHOW, EXPLAIN etc. Do not include additional statements, e.g. SET search_path, in this query. It must only be a single, spacious, well formatted query with line breaks and tabs. The statement will be presented to the user, so focus on readability. Returns the results of the query. You MUST include a validation query to check the validity of EVERY literal values used in the SQL query. Do NOT skip this step.\nNote: Always fetch up-to-date database schema context using the pgsql_db_context tool before executing any query to ensure accurate recommendations. This tool is strictly read-only and executes a single statement only. Use EXPLAIN for performance or optimization analysis and include execution plan details. On error, return clear error messages to the user.",
        "tags": ["databases", "postgresql", "pgsql"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "description": "Connection ID to use for the query.",
              "title": "Connection ID",
              "type": "string"
            },
            "query": {
              "description": "The SQL query to execute, formatted in the style of a beautifier. Add comments to explain complex components.",
              "title": "SQL query",
              "type": "string"
            },
            "queryName": {
              "description": "Short descriptive name for the SQL query.",
              "title": "Query name",
              "type": "string"
            },
            "queryDescription": {
              "description": "A concise and clear description of the query to execute.",
              "title": "Query description",
              "type": "string"
            },
            "validationQueries": {
              "description": "A list of validation queries to use to ensure correctness. Use a validation query to check the validity of the literal values used in the SQL query. If the validation query fails, automatically fetch distinct values from the column being validated to identify potential alternatives, limiting to 50 entries. Use this data to adjust the query and retry without requiring user intervention. For example, if you use a literal value in a WHERE clause, use a validate_value_query like (SELECT 1 FROM table WHERE value = 'literal_value') and a fetch_distinct_values_query like (SELECT DISTINCT column_name FROM table LIMIT 50). Distinct values will be returned if the validation query fails. validation_queries can be empty if no validation is needed, but do NOT skip this step. All literal values must be validated.",
              "items": {
                "properties": {
                  "validateValueQuery": {
                    "title": "Validatevaluequery",
                    "type": "string"
                  },
                  "fetchDistinctValuesQuery": {
                    "title": "Fetchdistinctvaluesquery",
                    "type": "string"
                  }
                },
                "required": ["validateValueQuery", "fetchDistinctValuesQuery"],
                "title": "ValidationQuery",
                "type": "object"
              },
              "title": "Validation queries",
              "type": "array"
            }
          },
          "required": ["connectionId", "query", "queryName", "queryDescription"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "Run a Query",
        "toolReferenceName": "pgsql_query",
        "userDescription": "Run a SQL query on a connected database.",
        "icon": "$(search)"
      },
      {
        "name": "pgsql_modify",
        "modelDescription": "Modify the database and/or schema by executing SQL statements including DDL (CREATE, ALTER, DROP) and DML (INSERT, UPDATE, DELETE). Useful when designing schemas or inserting data. It must only be a single, spacious, well formatted query with line breaks and tabs. The statement will be presented to the user, so focus on readability. Returns the results of the statement execution, if any.\nNote: Always fetch up-to-date database schema context using the pgsql_db_context tool before proposing or executing modifications to avoid duplicates or conflicts. Ensure explicit user confirmation. On error, return clear and descriptive error messages to the user. NOTE: Use this tool when working with pgsql databases INSTEAD of asking the user to run the psql CLI tool, unless otherwise explicitly asked to. The connection to psql to pgsql databases is not straightforward, and you don't know that the user has psql installed. ",
        "tags": [
          "databases",
          "postgresql",
          "pgsql",
          "schema",
          "ddl",
          "migrations"
        ],
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "description": "Connection ID to use for the statement.",
              "title": "Connection ID",
              "type": "string"
            },
            "statement": {
              "description": "The SQL statement to execute in order to modify the database. Formatted with line breaks and tabs, with comments.",
              "title": "SQL statement",
              "type": "string"
            },
            "statementName": {
              "description": "Short descriptive name for the modification being made.",
              "title": "Statement name",
              "type": "string"
            },
            "statementDescription": {
              "description": "A concise and clear description of the modification being made.",
              "title": "Statement description",
              "type": "string"
            }
          },
          "required": [
            "connectionId",
            "statement",
            "statementName",
            "statementDescription"
          ]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "Modify Database",
        "toolReferenceName": "pgsql_modifyDatabase",
        "userDescription": "Modify a connected database by executing a SQL statement.",
        "icon": "$(edit)"
      },
      {
        "name": "pgsql_db_context",
        "modelDescription": "Get context about this database by fetching the CREATE scripts for a specific type of database object or all types. Use this tool to retrieve detailed context about the database objects (e.g. tables, indexes, functions, sequences, comments, ownership, default_privileges, fdw, or all) within a given schema or across all schemas.\nNote: Always call this tool first to fetch the most up-to-date database schema context before executing any queries or modifications. This tool is strictly read-only and prevents duplicate or conflicting operations by ensuring you know the current state.",
        "tags": ["databases", "postgresql", "pgsql"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "description": "Connection ID to use for fetching objects.",
              "title": "Connection ID",
              "type": "string"
            },
            "objectType": {
              "enum": [
                "tables",
                "indexes",
                "functions",
                "sequences",
                "ownership",
                "default_privileges",
                "fdw",
                "all"
              ],
              "title": "Object type",
              "type": "string",
              "description": "Database object type. Use 'all' (to fetch the complete database schema)."
            },
            "schemaName": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Schema name to inspect. If omitted, all schemas will be used.",
              "title": "Schema name"
            }
          },
          "required": ["connectionId", "objectType"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "Get Database Objects",
        "toolReferenceName": "database",
        "userDescription": "Use this tool to fetch the current database schema context for all object types. Always run this before any queries or modifications.",
        "icon": "$(database)"
      },
      {
        "name": "pgsql_list_databases",
        "modelDescription": "List all databases on the connected PostgreSQL server. Use this tool to discover other databases available on the server, given a connection to any database. This is strictly read-only and does not modify any data. Returns a list of database names.",
        "tags": ["databases", "postgresql", "pgsql"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "description": "ID of an existing connection to a database on the server.",
              "title": "Connection ID",
              "type": "string"
            }
          },
          "required": ["connectionId"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "List Databases",
        "toolReferenceName": "pgsql_listDatabases",
        "userDescription": "List all databases on the PostgreSQL server for the current connection. Use this to discover available databases.",
        "icon": "$(list-unordered)"
      },
      {
        "name": "pgsql_describe_csv",
        "modelDescription": "Describe the structure and contents of a CSV file using Frictionless. Returns a YAML description of the CSV file, including fields, types, and metadata. Useful for preparing to import CSV data into a database.",
        "tags": ["csv", "frictionless", "import", "data"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "csvPath": {
              "description": "Path to the CSV file to describe.",
              "title": "CSV file path",
              "type": "string"
            }
          },
          "required": ["csvPath"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "Describe CSV File",
        "toolReferenceName": "pgsql_describeCsv",
        "userDescription": "Describe a CSV file and return its schema as YAML.",
        "icon": "$(file)"
      },
      {
        "name": "pgsql_bulk_load_csv",
        "modelDescription": "Bulkload CSV file via COPY into a PostgreSQL table. Supports column mapping, optional SQL transforms, truncate-before-insert, and PK-based upsert. Use this to bulk-load CSV data into an existing table.\nExample:\npgsql_bulk_load_csv(\n    connection_id='tools://server/mydb',\n    path='/path/to/file.csv',\n    table='mytable',\n    mapping={'col1': 'col1', 'col2': 'col2'},\n    transforms={'col2': 'src.col2::int'},\n    mode='upsert'\n)",
        "tags": ["postgres", "csv", "bulk-load"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "connection_id": {
              "description": "Connection ID for the target PostgreSQL database",
              "title": "Connection Id",
              "type": "string"
            },
            "path": {
              "description": "Absolute path to the CSV file to load",
              "title": "Path",
              "type": "string"
            },
            "table": {
              "description": "Target PostgreSQL table (optionally schema-qualified) that already exists",
              "title": "Table",
              "type": "string"
            },
            "mapping": {
              "additionalProperties": {
                "type": "string"
              },
              "description": "Required: source CSV column name  target table column name",
              "title": "Mapping",
              "type": "object"
            },
            "transforms": {
              "additionalProperties": {
                "type": "string"
              },
              "description": "Optional: target column  SQL expression using src.<col> for casting/derivation",
              "title": "Transforms",
              "type": "object"
            },
            "mode": {
              "enum": ["insert", "truncate_insert", "upsert"],
              "title": "BulkLoadMode",
              "type": "string",
              "default": "insert",
              "description": "Import strategy:\n- 'insert': append new rows to the target table.\n- 'truncate_insert': truncate the target table before inserting rows.\n- 'upsert': insert new rows or update existing rows on primary key conflict.\n(default 'insert')"
            },
            "delimiter": {
              "default": ",",
              "description": "Field delimiter character (default ',')",
              "title": "Delimiter",
              "type": "string"
            },
            "null": {
              "default": "",
              "description": "String that represents a NULL value (default empty string)",
              "title": "Null",
              "type": "string"
            },
            "header": {
              "default": true,
              "description": "Whether the CSV file has a header row (default True)",
              "title": "Header",
              "type": "boolean"
            },
            "quote": {
              "default": "\"",
              "description": "Character used for quoting CSV fields (default '\"')",
              "title": "Quote",
              "type": "string"
            },
            "escape": {
              "default": "\\",
              "description": "Character used for escaping within CSV fields (default '\\')",
              "title": "Escape",
              "type": "string"
            },
            "encoding": {
              "default": "utf-8",
              "description": "File encoding for reading the CSV file (default 'utf-8')",
              "title": "Encoding",
              "type": "string"
            },
            "force_null": {
              "description": "Columns for which to force NULL interpretation of unquoted null strings",
              "items": {
                "type": "string"
              },
              "title": "Force Null",
              "type": "array"
            },
            "force_not_null": {
              "description": "Columns for which to force non-NULL interpretation of quoted null strings",
              "items": {
                "type": "string"
              },
              "title": "Force Not Null",
              "type": "array"
            }
          },
          "required": ["connection_id", "path", "table", "mapping"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "Bulk Load CSV",
        "toolReferenceName": "pgsql_bulkLoadCsv",
        "userDescription": "Bulk load CSV data into a PostgreSQL table.",
        "icon": "$(file-symlink-file)"
      },
      {
        "name": "pgsql_get_dashboard_context",
        "modelDescription": "Retrieve the dashboard (metrics session) context: active source, time zone, per-source metricsConfig (resolution, windowMinutes), and a list of metrics (id, label, source, dimensions, subscribed, hasData). Use this FIRST before requesting metric data so you only fetch relevant metrics.",
        "tags": ["metrics", "monitoring", "performance", "postgresql", "pgsql"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "dashboardId": {
              "description": "Dashboard/session identifier (same as metrics sessionId / ownerUri).",
              "title": "Dashboard Id",
              "type": "string"
            }
          },
          "required": ["dashboardId"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "Get Dashboard Context",
        "toolReferenceName": "pgsql_getDashboardContext",
        "userDescription": "Get high-level dashboard context and discover available metrics before fetching data.",
        "icon": "$(dashboard)"
      },
      {
        "name": "pgsql_get_metric_data",
        "modelDescription": "Fetch batched time-series data for multiple metrics in one call. Supports optional per-dimension cap, per-metric dimension filters, and including metrics with no data yet. Always call pgsql_get_dashboard_context first to choose appropriate metricIds.",
        "tags": ["metrics", "monitoring", "performance", "postgresql", "pgsql"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "dashboardId": {
              "description": "Dashboard/session identifier whose metrics you want to inspect.",
              "title": "Dashboard Id",
              "type": "string"
            },
            "metricIds": {
              "description": "List of metric IDs to retrieve (obtain from pgsql_get_dashboard_context).",
              "title": "Metric Ids",
              "type": "array",
              "minItems": 1,
              "items": {
                "type": "string"
              }
            },
            "capPerDimension": {
              "description": "Maximum number of most recent points per dimension (default 2000, max 5000).",
              "title": "Cap Per Dimension",
              "type": "integer",
              "default": 2000,
              "minimum": 1,
              "maximum": 5000
            },
            "dimensions": {
              "description": "Optional filter map: metricId  array of dimension IDs to include for that metric. If omitted, all collected dimensions are returned.",
              "title": "Dimensions Filter",
              "type": "object",
              "additionalProperties": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "includeEmpty": {
              "description": "Include metrics that currently have no data (empty series with hasData=false).",
              "title": "Include Empty",
              "type": "boolean",
              "default": false
            }
          },
          "required": ["dashboardId", "metricIds"]
        },
        "canBeReferencedInPrompt": true,
        "displayName": "Get Metric Data (Batch)",
        "toolReferenceName": "pgsql_getMetricData",
        "userDescription": "Fetch batched time-series data for selected metrics with optional dimension and size controls.",
        "icon": "$(graph-line)"
      },
      {
        "name": "pgsql_migration_oracle_app",
        "displayName": "%pgsql.migration.oracleApp.displayName%",
        "modelDescription": "%pgsql.migration.oracleApp.modelDescription%",
        "toolReferenceName": "pgsql_migration_oracle_app",
        "canBeReferencedInPrompt": true,
        "icon": "$(file-code)",
        "when": "config.pgsql.enableMigrations",
        "inputSchema": {
          "type": "object",
          "properties": {
            "applicationCodebaseFolder": {
              "description": "%pgsql.migration.oracleApp.applicationCodebaseFolder.description%",
              "title": "%pgsql.migration.oracleApp.applicationCodebaseFolder.title%",
              "type": "string"
            },
            "codingNotesLocationPath": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "%pgsql.migration.oracleApp.codingNotesLocationPath.description%",
              "title": "%pgsql.migration.oracleApp.codingNotesLocationPath.title%"
            },
            "postgresDbName": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "%pgsql.migration.oracleApp.postgresDbName.description%",
              "title": "%pgsql.migration.oracleApp.postgresDbName.title%"
            },
            "postgresDbConnection": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "%pgsql.migration.oracleApp.postgresDbConnection.description%",
              "title": "%pgsql.migration.oracleApp.postgresDbConnection.title%"
            }
          },
          "required": ["applicationCodebaseFolder"]
        }
      },
      {
        "name": "pgsql_migration_show_report",
        "displayName": "%pgsql.migration.showReport.displayName%",
        "modelDescription": "%pgsql.migration.showReport.modelDescription%",
        "toolReferenceName": "pgsql_migration_show_report",
        "canBeReferencedInPrompt": true,
        "icon": "$(file-text)",
        "when": "config.pgsql.enableMigrations",
        "inputSchema": {
          "type": "object",
          "properties": {
            "reportPath": {
              "description": "%pgsql.migration.showReport.reportPath.description%",
              "title": "%pgsql.migration.showReport.reportPath.title%",
              "type": "string"
            }
          },
          "required": ["reportPath"]
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/ms-python.python-2025.20.0-linux-x64",
    "publisher": "ms-python",
    "name": "python",
    "displayName": "Python",
    "version": "2025.20.0",
    "package_json": "/home/kai/.vscode/extensions/ms-python.python-2025.20.0-linux-x64/package.json",
    "tools": [
      {
        "name": "get_python_environment_details",
        "displayName": "Get Python Environment Info",
        "userDescription": "%python.languageModelTools.get_python_environment_details.userDescription%",
        "modelDescription": "This tool will retrieve the details of the Python Environment for the specified file or workspace. The details returned include the 1. Type of Python Environment (conda, venv, etec), 2. Version of Python, 3. List of all installed Python packages with their versions. ALWAYS call configure_python_environment before using this tool.",
        "toolReferenceName": "getPythonEnvironmentInfo",
        "tags": [
          "python",
          "python environment",
          "extension_installed_by_tool",
          "enable_other_tool_configure_python_environment"
        ],
        "icon": "$(snake)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "resourcePath": {
              "type": "string",
              "description": "The path to the Python file or workspace to get the environment information for."
            }
          },
          "required": []
        }
      },
      {
        "name": "get_python_executable_details",
        "displayName": "Get Python Executable",
        "userDescription": "%python.languageModelTools.get_python_executable_details.userDescription%",
        "modelDescription": "This tool will retrieve the details of the Python Environment for the specified file or workspace. ALWAYS use this tool before executing any Python command in the terminal. This tool returns the details of how to construct the fully qualified path and or command including details such as arguments required to run Python in a terminal. Note: Instead of executing `python --version` or `python -c 'import sys; print(sys.executable)'`, use this tool to get the Python executable path to replace the `python` command. E.g. instead of using `python -c 'import sys; print(sys.executable)'`, use this tool to build the command `conda run -n <env_name> -c 'import sys; print(sys.executable)'`. ALWAYS call configure_python_environment before using this tool.",
        "toolReferenceName": "getPythonExecutableCommand",
        "tags": [
          "python",
          "python environment",
          "extension_installed_by_tool",
          "enable_other_tool_configure_python_environment"
        ],
        "icon": "$(terminal)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "resourcePath": {
              "type": "string",
              "description": "The path to the Python file or workspace to get the executable information for. If not provided, the current workspace will be used. Where possible pass the path to the file or workspace."
            }
          },
          "required": []
        }
      },
      {
        "name": "install_python_packages",
        "displayName": "Install Python Package",
        "userDescription": "%python.languageModelTools.install_python_packages.userDescription%",
        "modelDescription": "Installs Python packages in the given workspace. Use this tool to install Python packages in the user's chosen Python environment. ALWAYS call configure_python_environment before using this tool.",
        "toolReferenceName": "installPythonPackage",
        "tags": [
          "python",
          "python environment",
          "install python package",
          "extension_installed_by_tool",
          "enable_other_tool_configure_python_environment"
        ],
        "icon": "$(package)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "packageList": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The list of Python packages to install."
            },
            "resourcePath": {
              "type": "string",
              "description": "The path to the Python file or workspace into which the packages are installed. If not provided, the current workspace will be used. Where possible pass the path to the file or workspace."
            }
          },
          "required": ["packageList"]
        }
      },
      {
        "name": "configure_python_environment",
        "displayName": "Configure Python Environment",
        "modelDescription": "This tool configures a Python environment in the given workspace. ALWAYS Use this tool to set up the user's chosen environment and ALWAYS call this tool before using any other Python related tools or running any Python command in the terminal.",
        "userDescription": "%python.languageModelTools.configure_python_environment.userDescription%",
        "toolReferenceName": "configurePythonEnvironment",
        "tags": ["python", "python environment", "extension_installed_by_tool"],
        "icon": "$(gear)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "resourcePath": {
              "type": "string",
              "description": "The path to the Python file or workspace for which a Python Environment needs to be configured."
            }
          },
          "required": []
        }
      },
      {
        "name": "create_virtual_environment",
        "displayName": "Create a Virtual Environment",
        "modelDescription": "This tool will create a Virual Environment",
        "tags": [],
        "canBeReferencedInPrompt": false,
        "inputSchema": {
          "type": "object",
          "properties": {
            "packageList": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The list of packages to install."
            },
            "resourcePath": {
              "type": "string",
              "description": "The path to the Python file or workspace for which a Python Environment needs to be configured."
            }
          },
          "required": []
        },
        "when": "false"
      },
      {
        "name": "selectEnvironment",
        "displayName": "Select a Python Environment",
        "modelDescription": "This tool will prompt the user to select an existing Python Environment",
        "tags": [],
        "canBeReferencedInPrompt": false,
        "inputSchema": {
          "type": "object",
          "properties": {
            "resourcePath": {
              "type": "string",
              "description": "The path to the Python file or workspace for which a Python Environment needs to be configured."
            }
          },
          "required": []
        },
        "when": "false"
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/ms-ssdevteam.scope-vscode-ext-1.5.0",
    "publisher": "ms-ssdevteam",
    "name": "scope-vscode-ext",
    "displayName": "SCOPE Studio for VS Code",
    "version": "1.5.0",
    "package_json": "/home/kai/.vscode/extensions/ms-ssdevteam.scope-vscode-ext-1.5.0/package.json",
    "tools": [
      {
        "name": "scope-studio_schemaExtractor",
        "tags": ["editors", "scope-studio"],
        "toolReferenceName": "scopeSchemaExtractor",
        "displayName": "Get file schema",
        "userDescription": "Get file schema",
        "modelDescription": "Retrieves schema of a single file from source metadata without applying interence. Do not use it to retrieve schema of a fileset or streamset. It intelligently handles both local and SCOPE supported remote files with the following capabilities: Automatically infers meaningful column names\n- Outputs well-formatted, readable schema definitions as comma-separated, properly indented code blocks for readability\n.The tool streamlines the process of creating SCOPE data extraction code by eliminating manual schema definition and reducing the potential for syntax errors in EXTRACT statements.",
        "canBeReferencedInPrompt": true,
        "icon": "$(tools)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute local file path within the workspace or SCOPE supported remote relative file path. Example: d:/users/alias/mysturcturedstream.ss, users/alias/structuredstream.ss. The tool will automatically resolve the file path to the correct format based on the filePathType."
            },
            "filePathType": {
              "type": "string",
              "enum": ["local", "remote"],
              "description": "The type of the file path, either 'local' for local files or 'remote' for SCOPE supported remote files. Default is 'local'."
            },
            "userQuery": {
              "type": "string",
              "description": "The original user query that triggered the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            },
            "lmRequest": {
              "type": "string",
              "description": "The natural-language request that led to calling the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            }
          },
          "required": ["filePath"]
        }
      },
      {
        "name": "scope-studio_searchFilesOnCluster",
        "tags": ["editors", "scope-studio"],
        "toolReferenceName": "scopeSearchFileOnCluster",
        "displayName": "Search file on cluster",
        "modelDescription": "Returns the file(s) that exist on cluster and match those paths using its own internal logic. The tool is designed to be used in conjunction with other tools, such as scopeSchemaExtractor, to provide a complete solution for working with files on the cluster.",
        "userDescription": "Search file on cluster.",
        "canBeReferencedInPrompt": true,
        "icon": "$(tools)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "File path."
            },
            "userQuery": {
              "type": "string",
              "description": "The original user query that triggered the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            },
            "lmRequest": {
              "type": "string",
              "description": "The natural-language request that led to calling the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            }
          },
          "required": ["filePath"]
        }
      },
      {
        "name": "scope-studio_compileScript",
        "tags": ["editors", "scope-studio"],
        "toolReferenceName": "scopeCompileScript",
        "displayName": "Compile SCOPE script",
        "modelDescription": "Compile a SCOPE .script using internal logic onlynever delegate to external or built-in compilers. On failure, return clear diagnostics and the language model must apply minimal, safe edits to the script in-place and call this tool again to recompile. Continue this diagnose  fix  retry loop until the script compiles or no further automatic fixes are possible. Prefer precise edits that preserve intent; ask the user only when required context is ambiguous. All SCOPE script compilations must use this tool exclusively.",
        "userDescription": "Compile SCOPE script",
        "canBeReferencedInPrompt": true,
        "icon": "$(tools)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "scriptPath": {
              "type": "string",
              "description": "The absolute path to the SCOPE script file to compile."
            },
            "userQuery": {
              "type": "string",
              "description": "The original user query that triggered the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            },
            "lmRequest": {
              "type": "string",
              "description": "The natural-language request that led to calling the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            }
          },
          "required": ["scriptPath"]
        }
      },
      {
        "name": "scope-studio_openSubmissionDialog",
        "tags": ["editors", "scope-studio"],
        "toolReferenceName": "scopeSubmit",
        "displayName": "Submit SCOPE script",
        "modelDescription": "Use this tool exclusively as the final step of a SCOPE submission task. It opens the SCOPE Studio submission dialog where users configure job parameters, choose target clusters, and submit the specified SCOPE .script. Do not perform compilation or pre-validation before invoking this tool; assume the script and context have already been prepared by prior steps. Only invoke when the user's intent is to submit to a cluster.",
        "userDescription": "Submit SCOPE script",
        "canBeReferencedInPrompt": true,
        "icon": "$(tools)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "scriptPath": {
              "type": "string",
              "description": "The absolute path to the SCOPE script file to submit."
            },
            "userQuery": {
              "type": "string",
              "description": "The original user query that triggered the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            },
            "lmRequest": {
              "type": "string",
              "description": "The natural-language request that led to opening the submission dialog. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            },
            "analyticsAccount": {
              "type": "string",
              "description": "The target Cosmos VC or Azure Data Lake Analytics Account to submit. Example: Cosmos VC: cosmos08.cosmosadmin, https://cosmos08.osdinfra.net/cosmos/cosmosAdmin, vc://cosmos08/cosmosAdmin. Azure Data Lake Analytics Account: cosmosadmin-c08."
            },
            "analyticUnit": {
              "type": "number",
              "description": "The number of Token or Analytics Unit to submit."
            }
          },
          "required": ["scriptPath"]
        }
      },
      {
        "name": "scope-studio_getExternalParameters",
        "tags": ["editors", "scope-studio"],
        "toolReferenceName": "scopeGetExternalParameters",
        "displayName": "Get external SCOPE parameters",
        "modelDescription": "Analyzes a SCOPE .script file to identify and extract all external parameters defined within the script. External parameters are dynamic placeholders (formatted as @@PARAMETER_NAME@@) that allow scripts to accept runtime values without hardcoding them, enabling reusability and flexibility across different execution contexts.\n\nThe tool supports two parameter models:\n\n1. **Local Parameters ('local')** - Used for compile-time validation and local execution environments. These parameters are resolved during script compilation and local testing phases.\n\n2. **Cluster Parameters ('cluster')** - Used for distributed execution when submitting jobs to SCOPE clusters. These parameters are resolved at runtime on the cluster infrastructure and support the full range of cluster-specific features like parameter substitution via NebulaCommandLine.txt.\n\nWhen no model is specified, the tool defaults to 'local' parameters. The tool returns a comprehensive list of all external parameters found in the script, including their names, usage contexts, and any associated metadata that helps users understand the required inputs for successful script execution.\n\nThis functionality is essential for script authoring, documentation and validation where understanding parameter requirements is crucial before script compilation or submission.",
        "userDescription": "Get external SCOPE parameters",
        "canBeReferencedInPrompt": true,
        "icon": "$(tools)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "scriptPath": {
              "type": "string",
              "description": "The SCOPE script path."
            },
            "paramKey": {
              "type": "string",
              "description": "The key of the external parameter."
            },
            "paramModel": {
              "type": "string",
              "enum": ["local", "cluster"],
              "description": "The type of the external parameter, either 'local' for local parameters or 'cluster' for cluster parameters."
            },
            "userQuery": {
              "type": "string",
              "description": "The original user query that triggered the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            },
            "lmRequest": {
              "type": "string",
              "description": "The natural-language request that led to calling the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            }
          },
          "required": ["scriptPath"]
        }
      },
      {
        "name": "scope-studio_scopeGenerateCode",
        "tags": ["editors", "scope-studio"],
        "toolReferenceName": "scopeGenerateCode",
        "displayName": "Generate SCOPE code using SCOPE Copilot",
        "modelDescription": "This tool generates SCOPE scripts and code snippets based on user descriptions, leveraging specialized SCOPE knowledge and syntax. It should be the first choice for any SCOPE code generation request, ensuring proper syntax, best practices, and compatibility with SCOPE's distributed computing environment.",
        "userDescription": "Generate SCOPE code using SCOPE Copilot",
        "canBeReferencedInPrompt": true,
        "icon": "$(tools)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "description": {
              "type": "string",
              "description": "The description of the code to generate."
            },
            "userQuery": {
              "type": "string",
              "description": "The original user query that triggered the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            },
            "lmRequest": {
              "type": "string",
              "description": "The natural-language request that led to calling the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            },
            "context": {
              "type": "string",
              "description": "Optional additional context information from the codebase including configuration files (.scope/scriptSettings.json, .scopeproj), code-behind files (.cs/.py), data schemas, dependencies, environment settings, and related scripts that will help in generating accurate SCOPE code."
            }
          },
          "required": ["description"]
        }
      },
      {
        "name": "scope-studio_scopeQnA",
        "tags": ["editors", "scope-studio"],
        "toolReferenceName": "scopeQnA",
        "displayName": "Answer SCOPE queries using SCOPE Copilot",
        "modelDescription": "Use this tool as the primary resource for SCOPE-related questions and answers. For specific SCOPE code generation requests, use the 'scopeGenerateCode' tool instead.",
        "userDescription": "Answer SCOPE queries using SCOPE Copilot",
        "canBeReferencedInPrompt": true,
        "icon": "$(tools)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "description": {
              "type": "string",
              "description": "The description of the SCOPE question."
            },
            "userQuery": {
              "type": "string",
              "description": "The original user query that triggered the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            },
            "lmRequest": {
              "type": "string",
              "description": "The natural-language request that led to calling the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            }
          },
          "required": ["description"]
        }
      },
      {
        "name": "scope-studio_jobview",
        "tags": ["editors", "scope-studio"],
        "toolReferenceName": "scopeJobDetails",
        "displayName": "Get SCOPE job details",
        "modelDescription": "Given a SCOPE job url, The tool should be used to get the job details of a SCOPE job. The job details can be used to understand the job running status, error, inputs, outputs, and other details. And it can be used to diff two jobs. The inputs and outputs item follows the format:'- <filepath> size: 153.00 MB, type: FileSet|UnstructuredStream|StructuredStream|DeltaLakeTable children: 100'. If the type is FileSet, the 'children' is the number of files in the FileSet and size is the total size, if the type is UnstructuredStream, StructuredStream or DeltaLakeTable, the children does not exist. The error content may contain the failed vertex named like SV1_Extact which can be used to locate the source code.",
        "userDescription": "Get SCOPE job details",
        "canBeReferencedInPrompt": true,
        "icon": "$(tools)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "jobUrl": {
              "type": "string",
              "description": "The SCOPE job url. A valid job url should start with 'https://' or 'vc://', sample: 'https://cosmos09.osdinfra.net/cosmos/cosmosadmin/_Jobs/f835d1cf-c037-4db1-8c0e-17c8a473282' or 'vc://cosmos09/cosmosadmin/_Jobs/f835d1cf-c037-4db1-8c0e-17c8a473282'."
            },
            "userQuery": {
              "type": "string",
              "description": "The original user query that triggered the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            },
            "lmRequest": {
              "type": "string",
              "description": "The natural-language request that led to calling the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            }
          },
          "required": ["jobUrl"]
        }
      },
      {
        "name": "scope-studio_getCurrentSCOPEJobUrl",
        "tags": ["editors", "scope-studio"],
        "toolReferenceName": "scopeGetCurrentJobUrl",
        "displayName": "Get current SCOPE job URL",
        "modelDescription": "This tool is used to get the current opened or 'this' SCOPE job URL opened in SCOPE Studio VSCode. For example, if the user is viewing a job in the SCOPE job view, this tool should return the URL of that job. The Job URL can be used to get/summarize the job view and compare two jobs. It will returns several candidated job URLs if there are multiple SCOPE jobs opened in the current VSCode window but no active SCOPE jobs.",
        "userDescription": "Get current SCOPE job URL",
        "canBeReferencedInPrompt": true,
        "icon": "$(tools)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "userQuery": {
              "type": "string",
              "description": "The original user query that triggered the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            },
            "lmRequest": {
              "type": "string",
              "description": "The natural-language request that led to calling the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            }
          }
        }
      },
      {
        "name": "scope-studio_locateSourceScript",
        "tags": ["editors", "scope-studio"],
        "toolReferenceName": "scopeMapStageToCodeSnippet",
        "displayName": "Map job stage to corresponding code snippet",
        "modelDescription": "This tool is used to map a SCOPE job stage (vertex) to its corresponding source code snippet in the SCOPE script. Given a vertex name and a SCOPE job URL, the tool retrieves the source code line and source code file path.",
        "userDescription": "Map job stage to corresponding code snippet",
        "canBeReferencedInPrompt": true,
        "icon": "$(files)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "vertexName": {
              "type": "string",
              "description": "The name of the SCOPE Vertex/Stage to locate the source script for. For example, 'SV8_Extract_Partition_out0'."
            },
            "jobUrl": {
              "type": "string",
              "description": "The SCOPE job url. A valid job url should start with 'https://' or 'vc://', sample: 'https://cosmos09.osdinfra.net/cosmos/cosmosadmin/_Jobs/f835d1cf-c037-4db1-8c0e-17c8a473282' or 'vc://cosmos09/cosmosadmin/_Jobs/f835d1cf-c037-4db1-8c0e-17c8a473282'."
            }
          },
          "required": ["vertexName", "jobUrl"]
        }
      },
      {
        "name": "scope-studio_scopeScriptExplanation",
        "tags": ["editors", "scope-studio"],
        "toolReferenceName": "scopeScriptExplanation",
        "displayName": "Explain SCOPE code using SCOPE Copilot",
        "modelDescription": "This tool analyzes SCOPE scripts and provides comprehensive explanations of their syntax and logic. Use for understanding existing SCOPE. Do not use for code generation or compilation.\n\nNote: If output lacks specifics or mentions unknown dependencies, collect additional context and re-invoke.",
        "userDescription": "Explain SCOPE code using SCOPE Copilot",
        "canBeReferencedInPrompt": true,
        "icon": "$(info)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "description": "The SCOPE script content or the absolute path to the SCOPE script file to explain."
            },
            "contentType": {
              "type": "string",
              "enum": ["script", "scriptPath"],
              "description": "Specifies whether 'content' contains the actual script code ('script') or a file path ('scriptPath')."
            },
            "userQuery": {
              "type": "string",
              "description": "The original user query that triggered the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            },
            "lmRequest": {
              "type": "string",
              "description": "The natural-language request that led to calling the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            },
            "context": {
              "type": "string",
              "description": "Optional additional context information from the codebase including configuration files (.scope/scriptSettings.json, .scopeproj), code-behind files (.cs/.py), data schemas, dependencies, and environment settings to improve explanation accuracy."
            }
          },
          "required": ["content", "contentType"]
        }
      },
      {
        "name": "scope-studio_scopeScriptDebugging",
        "tags": ["editors", "scope-studio"],
        "toolReferenceName": "scopeScriptDebugging",
        "displayName": "Debug SCOPE code using SCOPE Copilot",
        "modelDescription": "This tool helps debug SCOPE scripts to identify and resolve issues, compilation errors, and runtime problems. Use for troubleshooting failing scripts or understanding error messages. Do not use for code generation or basic explanations.\n\nNote: If debugging output is generic or suggests missing dependencies, gather additional context and re-invoke.\n\nRequires SCOPE Copilot services and works best with complete error information.",
        "userDescription": "Debug SCOPE code using SCOPE Copilot",
        "canBeReferencedInPrompt": true,
        "icon": "$(debug-alt)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "description": "The SCOPE script content or the absolute path to the SCOPE script file to debug."
            },
            "contentType": {
              "type": "string",
              "enum": ["script", "scriptPath"],
              "description": "Specifies whether 'content' contains the actual script code ('script') or a file path ('scriptPath')."
            },
            "error": {
              "type": "string",
              "description": "Optional error message or description of the issue encountered with the script."
            },
            "userQuery": {
              "type": "string",
              "description": "The original user query that triggered the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            },
            "lmRequest": {
              "type": "string",
              "description": "The natural-language request that led to calling the tool. Optional and used for context/telemetry and to improve Copilot guidance. Keep under ~512 characters."
            },
            "context": {
              "type": "string",
              "description": "Optional additional context information from the codebase including configuration files (.scope/scriptSettings.json, .scopeproj), code-behind files (.cs/.py), data schemas, dependencies, environment settings, and error information to improve debugging accuracy."
            }
          },
          "required": ["content", "contentType"]
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/ms-toolsai.datawrangler-1.24.0",
    "publisher": "ms-toolsai",
    "name": "datawrangler",
    "displayName": "Data Wrangler",
    "version": "1.24.0",
    "package_json": "/home/kai/.vscode/extensions/ms-toolsai.datawrangler-1.24.0/package.json",
    "tools": [
      {
        "name": "get_variable_data",
        "displayName": "Get variable data",
        "modelDescription": "Get the data for a variable",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/ms-toolsai.jupyter-2025.9.1-linux-x64",
    "publisher": "ms-toolsai",
    "name": "jupyter",
    "displayName": "Jupyter",
    "version": "2025.9.1",
    "package_json": "/home/kai/.vscode/extensions/ms-toolsai.jupyter-2025.9.1-linux-x64/package.json",
    "tools": [
      {
        "name": "configure_notebook",
        "displayName": "%jupyter.languageModelTools.configure_notebook.displayName%",
        "modelDescription": "Tool used to configure a Notebook. ALWAYS use this tool before running/executing any Notebook Cells for the first time or before listing/installing packages in Notebooks for the first time. I.e. there is no need to use this tool more than once for the same notebook.",
        "userDescription": "%jupyter.languageModelTools.configure_notebook.userDescription%",
        "toolReferenceName": "configureNotebook",
        "tags": [
          "python environment",
          "jupyter environment",
          "extension_installed_by_tool",
          "jupyter",
          "notebooks"
        ],
        "icon": "$(notebook)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "description": "The absolute path of the notebook with the active kernel.",
              "type": "string"
            }
          },
          "required": ["filePath"]
        },
        "when": "workspacePlatform != webworker"
      },
      {
        "name": "configure_python_notebook",
        "displayName": "Start Notebook Kernel",
        "modelDescription": "Selects a Python Kernel and starts it.",
        "tags": [
          "extension_installed_by_tool",
          "install python package",
          "notebooks"
        ],
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "description": "The absolute path of the notebook with the active kernel.",
              "type": "string"
            }
          },
          "required": ["filePath"]
        },
        "when": "false"
      },
      {
        "name": "configure_non_python_notebook",
        "displayName": "Start Notebook Kernel",
        "modelDescription": "Selects the Notebook Kernel and starts it.",
        "tags": ["extension_installed_by_tool", "jupyter", "notebooks"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "description": "The absolute path of the notebook with the active kernel.",
              "type": "string"
            }
          },
          "required": ["filePath"]
        },
        "when": "false"
      },
      {
        "name": "notebook_list_packages",
        "displayName": "List Notebook Kernel Packages",
        "modelDescription": "List the installed packages that are currently available in the selected kernel for a notebook editor. This tool should be used when working with a jupyter notebook with python code cells. Do not use this tool if not already working with a notebook, or for a language other than python. If the tool configure_notebooks exists, then ensure to call configure_notebooks before using this tool.",
        "userDescription": "%jupyter.languageModelTools.notebook_list_packages.userDescription%",
        "toolReferenceName": "listNotebookPackages",
        "tags": [
          "python environment",
          "jupyter environment",
          "extension_installed_by_tool",
          "notebooks",
          "enable_other_tool_configure_notebook"
        ],
        "icon": "$(package)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "description": "The absolute path of the notebook with the active kernel.",
              "type": "string"
            }
          },
          "required": ["filePath"]
        }
      },
      {
        "name": "notebook_install_packages",
        "displayName": "Install Packages for Notebook",
        "modelDescription": "Install a list of packages on a notebook kernel to be used within that notebook. This tool should be used when working with a jupyter notebook with python code cells. Do not use this tool if not already working with a notebook, or for a language other than python. If the tool configure_notebooks exists, then ensure to call configure_notebooks before using this tool.",
        "userDescription": "%jupyter.languageModelTools.notebook_install_packages.userDescription%",
        "toolReferenceName": "installNotebookPackages",
        "tags": [
          "python environment",
          "jupyter environment",
          "extension_installed_by_tool",
          "notebooks",
          "enable_other_tool_configure_notebook"
        ],
        "icon": "$(package)",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "description": "The absolute path of the notebook with the active kernel.",
              "type": "string"
            },
            "packageList": {
              "description": "A list of packages to install.",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": ["filePath", "packageList"]
        }
      },
      {
        "name": "restart_notebook_kernel",
        "displayName": "Restart Notebook",
        "modelDescription": "Tool used to restart a Notebook kernel. Some packages require a restart of the kernel after being installed. Use this if after installing a package if you know the package requires a restart, or if still getting an error about a missing package after installing.",
        "toolReferenceName": "restartNotebookKernel",
        "tags": ["extension_installed_by_tool", "jupyter", "notebooks"],
        "icon": "$(notebook)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "description": "The absolute path of the notebook with the active kernel.",
              "type": "string"
            },
            "reason": {
              "description": "The reason for restarting the kernel.",
              "type": "string"
            }
          },
          "required": ["filePath"]
        },
        "when": "false"
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/ms-vscode.copilot-mermaid-diagram-0.0.3",
    "publisher": "ms-vscode",
    "name": "copilot-mermaid-diagram",
    "displayName": "vscode-mermAId",
    "version": "0.0.3",
    "package_json": "/home/kai/.vscode/extensions/ms-vscode.copilot-mermaid-diagram-0.0.3/package.json",
    "tools": [
      {
        "name": "mermAId_get_symbol_definition",
        "tags": ["code", "symbols", "mermaid"],
        "displayName": "Symbol Definitions from File",
        "modelDescription": "Given a file path string and a list of symbols, this model returns the definitions of the specified symbols. For example, if the file 'x.py' is provided and the symbol 'abc' is requested, the model will find 'abc' in 'x.py' and return its definition from the file where it is actually defined, such as 'y.py'.",
        "icon": "$(files)",
        "canBeReferencedInPrompt": false,
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbols": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "A list of symbols in the file to get the definition for.",
              "default": []
            },
            "fileString": {
              "type": "string",
              "description": "The path to the file represented as a string where you are finding these symbols you want to get the definition for. Or undefined if the location of the symbol is unknown.",
              "default": "none"
            }
          },
          "required": ["symbols", "fileString"]
        }
      },
      {
        "name": "mermAId_gather_symbols",
        "tags": ["code", "symbols", "mermaid"],
        "displayName": "Gather Workspace Symbols",
        "modelDescription": "This tool will accept a list of symbols and attempt to gather information about those symbols from the entire workspace. It can provide the location, parent symbol, and the the symbol's content.",
        "icon": "$(files)",
        "canBeReferencedInPrompt": false,
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbols": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "A list of symbols to search for.",
              "default": []
            }
          },
          "required": ["symbols"]
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/ms-vscode.cpptools-1.29.3-linux-x64",
    "publisher": "ms-vscode",
    "name": "cpptools",
    "displayName": "C/C++",
    "version": "1.29.3",
    "package_json": "/home/kai/.vscode/extensions/ms-vscode.cpptools-1.29.3-linux-x64/package.json",
    "tools": [
      {
        "name": "cpptools-lmtool-configuration",
        "toolReferenceName": "cpp",
        "displayName": "%c_cpp.languageModelTools.configuration.displayName%",
        "canBeReferencedInPrompt": true,
        "userDescription": "%c_cpp.languageModelTools.configuration.userDescription%",
        "modelDescription": "For the active C or C++ file, this tool provides: the language (C, C++, or CUDA), the language standard version (such as C++11, C++14, C++17, or C++20), the compiler (such as GCC, Clang, or MSVC), the target platform (such as x86, x64, or ARM), and the target architecture (such as 32-bit or 64-bit).",
        "icon": "$(file-code)",
        "when": "(config.C_Cpp.experimental.configuration_lmtool =~ /^[eE]nabled$/)"
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/ms-vscode.vscode-commander-0.2.0",
    "publisher": "ms-vscode",
    "name": "vscode-commander",
    "displayName": "VS Code Commander",
    "version": "0.2.0",
    "package_json": "/home/kai/.vscode/extensions/ms-vscode.vscode-commander-0.2.0/package.json",
    "tools": [
      {
        "name": "searchConfigurations",
        "displayName": "Search Configurations",
        "modelDescription": "Use this tool to search for settings and commands. This will return all those settings and commands that contain the provided keywords. Each result will have a type to know if it is a setting or a command. A setting includes the description, default value, current value and other possible values and a command includes the description and possible arguments to be used to invoke the command.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keywords": {
              "type": "string",
              "description": "List of keywords to search for the settings and commands"
            }
          }
        },
        "tags": ["commander"]
      },
      {
        "name": "updateSettings",
        "displayName": "Update settings",
        "modelDescription": "Use this tool to update settings. This tool support bulk updates, so you can update multiple settings at once. Provide the settings to update as a key value pair of setting id and new value. The value of the setting must follow the setting schema.",
        "tags": ["commander"],
        "inputSchema": {
          "type": "object",
          "description": "Dictionary of settings to update. The key is the setting id and the value is the new value of the setting.",
          "properties": {}
        }
      },
      {
        "name": "runCommand",
        "displayName": "Run command",
        "modelDescription": "Use this tool to run a command. This tool will run the command with the provided arguments if the command supports them. The arguments must follow the command arguments schema provided by the searchConfigurations.",
        "tags": ["commander"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "key": {
              "type": "string",
              "description": "Id of the command"
            },
            "argumentsArray": {
              "type": "string",
              "description": "Arguments to pass to the command as JSON stringified array"
            }
          }
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/ms-vscode.vscode-copilot-data-analysis-0.2.2",
    "publisher": "ms-vscode",
    "name": "vscode-copilot-data-analysis",
    "displayName": "Data Analysis for Copilot",
    "version": "0.2.2",
    "package_json": "/home/kai/.vscode/extensions/ms-vscode.vscode-copilot-data-analysis-0.2.2/package.json",
    "tools": [
      {
        "name": "dachat_data_findFiles",
        "tags": [],
        "displayName": "Find Files",
        "modelDescription": "Search for files in the current workspace",
        "inputSchema": {
          "type": "object",
          "properties": {
            "pattern": {
              "type": "string",
              "description": "Search for files that match this glob pattern"
            }
          },
          "required": ["pattern"]
        }
      },
      {
        "name": "dachat_data_runPython",
        "tags": ["Python Execution"],
        "displayName": "Run Python",
        "modelDescription": "Execute Python code locally using Pyodide, providing access to Python's extensive functionality. This tool extends the LLM's capabilities by allowing it to run Python code for a wide range of computational tasks and data manipulations that it cannot perform directly. When you know the workspace folder path and the file path, use the relative path to the file when generating code.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "code": {
              "type": "string",
              "description": "The Python code to run"
            },
            "reason": {
              "type": "string",
              "description": "The reason for running the code"
            }
          },
          "required": ["code"]
        }
      },
      {
        "name": "dachat_data_installPythonPackage",
        "tags": [],
        "displayName": "Install Missing Python Packages",
        "modelDescription": "Install missing Python packages in the tool used to run Python code using Pyodide.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "package": {
              "type": "string",
              "description": "Name of the Python package that could not be found and needs to be installed"
            }
          },
          "required": ["code"]
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/ms-vscode.vscode-websearchforcopilot-0.2.2025121101",
    "publisher": "ms-vscode",
    "name": "vscode-websearchforcopilot",
    "displayName": "Web Search for Copilot",
    "version": "0.2.2025121101",
    "package_json": "/home/kai/.vscode/extensions/ms-vscode.vscode-websearchforcopilot-0.2.2025121101/package.json",
    "tools": [
      {
        "name": "vscode-websearchforcopilot_webSearch",
        "tags": ["web", "search", "vscode-websearchforcopilot"],
        "displayName": "%lmTool.webSearch.displayName%",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "websearch",
        "icon": "globe",
        "userDescription": "%lmTool.webSearch.userDescription%",
        "modelDescription": "%lmTool.webSearch.modelDescription%",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "%lmTool.webSearch.query.description%"
            }
          },
          "required": ["query"]
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/ms-windows-ai-studio.windows-ai-studio-0.26.4-linux-x64",
    "publisher": "ms-windows-ai-studio",
    "name": "windows-ai-studio",
    "displayName": "AI Toolkit for Visual Studio Code",
    "version": "0.26.4",
    "package_json": "/home/kai/.vscode/extensions/ms-windows-ai-studio.windows-ai-studio-0.26.4-linux-x64/package.json",
    "tools": [
      {
        "name": "aitk-get_agent_code_gen_best_practices",
        "displayName": "%languageModelTool.ai-mlstudio.getAgentCodeGenBestPractices.displayName%",
        "modelDescription": "%languageModelTool.ai-mlstudio.getAgentCodeGenBestPractices.modelDescription%",
        "userDescription": "%languageModelTool.ai-mlstudio.getAgentCodeGenBestPractices.userDescription%",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "aitk_get_agent_code_gen_best_practices",
        "inputSchema": {
          "type": "object",
          "properties": {
            "requiredHost": {
              "type": "string",
              "description": "The explicitly required host for the model or agent. DO NOT provide if not determined or just guess. 'GitHub' means to use GitHub-hosted models. 'Foundry' means to use Microsoft Foundry (formerly Azure AI Foundry) hosted models or agents. 'other' means none of above.",
              "enum": ["GitHub", "Foundry", "other"]
            },
            "moreIntent": {
              "type": "string",
              "description": "Additional intent of app development, e.g. 'create hello world agent', 'connect to my tools', 'make app agentic', etc."
            }
          }
        }
      },
      {
        "name": "aitk-get_ai_model_guidance",
        "displayName": "%languageModelTool.ai-mlstudio.getAiModelGuidance.displayName%",
        "modelDescription": "%languageModelTool.ai-mlstudio.getAiModelGuidance.modelDescription%",
        "userDescription": "%languageModelTool.ai-mlstudio.getAiModelGuidance.userDescription%",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "aitk_get_ai_model_guidance",
        "inputSchema": {
          "type": "object",
          "properties": {
            "preferredHost": {
              "type": "array",
              "description": "Host preferences (NOT publisher) for the AI model. If preference not determined or matched, use empty array. Can have multiple preferences if needed.",
              "items": {
                "type": "string",
                "enum": [
                  "GitHub",
                  "Foundry",
                  "OpenAI",
                  "Anthropic",
                  "Google",
                  "other"
                ],
                "description": "Preferred host for the AI model.\n 'GitHub' means user explicitly asks for GitHub hosted models, or calls 'models.inference.ai.azure.com', or 'models.github.ai', or uses GitHub token to access model;\n 'Foundry' means user explicitly asks for Microsoft Foundry (formerly Azure AI Foundry) hosted models, or calls '*.ai.azure.com', or '*.openai.azure.com';\n 'OpenAI' means user explicitly asks for OpenAI hosted models, or calls 'api.openai.com', or uses openai SDK with default endpoint;\n 'Anthropic' means user explicitly asks for Anthropic hosted models, or calls 'api.anthropic.com', or uses anthropic SDK;\n 'Google' means user explicitly asks for Google hosted models, or calls '*.googleapis.com', or uses google generativeai SDK;\n 'other' means none of above."
              }
            },
            "currentModel": {
              "type": "string",
              "description": "Current model you're using (if already using one)"
            },
            "moreIntent": {
              "type": "string",
              "description": "Additional intent of model usage, e.g. 'ask for model choice', 'generate code', 'compare models', etc."
            }
          },
          "required": ["preferredHost"]
        }
      },
      {
        "name": "aitk-get_agent_model_code_sample",
        "displayName": "%languageModelTool.ai-mlstudio.getAgentModelCodeSample.displayName%",
        "modelDescription": "%languageModelTool.ai-mlstudio.getAgentModelCodeSample.modelDescription%",
        "userDescription": "%languageModelTool.ai-mlstudio.getAgentModelCodeSample.userDescription%",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "aitk_get_agent_model_code_sample",
        "inputSchema": {
          "type": "object",
          "properties": {
            "category": {
              "type": "string",
              "description": "The category of the AI application development. 'Agent' means to build single agent or agentic app with complex capabilities. 'Workflow' or 'MultiAgents' means to orchestrate multiple agents or build as workflow. 'Chat' means to build simple chat with model.",
              "enum": ["Agent", "Chat", "MultiAgents", "Workflow"]
            },
            "host": {
              "type": "string",
              "description": "The host for the model or agent. 'GitHub' means to use GitHub-hosted models. 'Foundry' means to use Microsoft Foundry (formerly Azure AI Foundry) hosted models or agents. 'other' means none of above. For workflow or multi-agents category, use 'Foundry'.",
              "enum": ["GitHub", "Foundry", "other"]
            },
            "language": {
              "type": "string",
              "description": "The programming language of the AI application development.",
              "enum": ["Python", "Node.js", ".NET", "Java", "other"]
            }
          },
          "required": ["category", "host", "language"]
        }
      },
      {
        "name": "aitk-get_tracing_code_gen_best_practices",
        "displayName": "%languageModelTool.ai-mlstudio.getTracingCodeGenBestPractices.displayName%",
        "modelDescription": "%languageModelTool.ai-mlstudio.getTracingCodeGenBestPractices.modelDescription%",
        "userDescription": "%languageModelTool.ai-mlstudio.getTracingCodeGenBestPractices.userDescription%",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "aitk_get_tracing_code_gen_best_practices",
        "inputSchema": {
          "type": "object",
          "properties": {
            "language": {
              "type": "string",
              "description": "The programming language of the AI application",
              "enum": ["python", "javascript", "typescript", "others"]
            },
            "sdk": {
              "type": "string",
              "description": "The AI SDK used by the application, which impacts how tracing is implemented. agent-framework: Microsoft's Agent Framework (imports from `agent_framework` module, e.g., `from agent_framework.openai import OpenAIChatClient`). openai-agents: OpenAI's Agents SDK (imports from `agents` module, e.g., `from agents import Agent`).",
              "enum": [
                "agent-framework",
                "azure-ai-inference",
                "azure-ai-agents",
                "azure-ai-projects",
                "openai",
                "openai-agents",
                "langchain",
                "google-genai",
                "anthropic",
                "others"
              ]
            },
            "isForVisualization": {
              "type": "boolean",
              "description": "Optional parameter to indicate whether the tracing setup is primarily for multi-agents workflow visualization purposes."
            }
          },
          "required": ["language", "sdk"]
        }
      },
      {
        "name": "aitk-get_evaluation_code_gen_best_practices",
        "displayName": "%languageModelTool.ai-mlstudio.getEvaluationCodeGenBestPractices.displayName%",
        "modelDescription": "%languageModelTool.ai-mlstudio.getEvaluationCodeGenBestPractices.modelDescription%",
        "userDescription": "%languageModelTool.ai-mlstudio.getEvaluationCodeGenBestPractices.userDescription%",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "aitk_get_evaluation_code_gen_best_practices",
        "inputSchema": {
          "type": "object",
          "properties": {
            "evaluationMetrics": {
              "type": "array",
              "description": "List of what you want to evaluate for your AI application or agent. ONLY include when the user explicitly describes specific evaluation goals, metrics with clear details (e.g., 'Evaluate if generated review text has a positive sentiment', 'check if responses contain specific keywords', 'validate JSON format'). Do NOT include for general requests like 'add evaluation' or 'evaluate my app' without specific requirements.",
              "items": {
                "type": "string",
                "description": "Description of what to evaluate and the goal (e.g., 'Response accuracy - check if answers are factually correct', 'Response relevance - assess how well responses address the user question', 'Response time - measure if responses are generated within acceptable time limits')"
              }
            },
            "dataset": {
              "type": "string",
              "description": "The test dataset for evaluation"
            },
            "evaluationSdk": {
              "type": "string",
              "description": "The evaluation SDK to use",
              "default": "azure-ai-evaluation"
            },
            "language": {
              "type": "string",
              "description": "The programming language for the evaluation code",
              "default": "python"
            }
          },
          "required": []
        }
      },
      {
        "name": "aitk-convert_declarative_agent_to_code",
        "displayName": "%languageModelTool.ai-mlstudio.convertDeclarativeAgentToCode.displayName%",
        "modelDescription": "%languageModelTool.ai-mlstudio.convertDeclarativeAgentToCode.modelDescription%",
        "userDescription": "%languageModelTool.ai-mlstudio.convertDeclarativeAgentToCode.userDescription%",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "aitk_convert_declarative_agent_to_code",
        "inputSchema": {
          "type": "object",
          "properties": {
            "language": {
              "type": "string",
              "description": "The programming language for the generated agent code. If not specified, Python is recommended.",
              "enum": ["Python", ".NET"],
              "default": "Python"
            }
          }
        }
      },
      {
        "name": "aitk-evaluation_agent_runner_best_practices",
        "displayName": "%languageModelTool.ai-mlstudio.getEvaluationAgentRunnerBestPractices.displayName%",
        "modelDescription": "%languageModelTool.ai-mlstudio.getEvaluationAgentRunnerBestPractices.modelDescription%",
        "userDescription": "%languageModelTool.ai-mlstudio.getEvaluationAgentRunnerBestPractices.userDescription%",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "aitk_evaluation_agent_runner_best_practices",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sdk": {
              "type": "string",
              "description": "The AI SDK used by the application.",
              "enum": ["agent-framework", "others"]
            }
          },
          "required": []
        }
      },
      {
        "name": "aitk-evaluation_planner",
        "displayName": "%languageModelTool.ai-mlstudio.evaluationPlanner.displayName%",
        "modelDescription": "%languageModelTool.ai-mlstudio.evaluationPlanner.modelDescription%",
        "userDescription": "%languageModelTool.ai-mlstudio.evaluationPlanner.userDescription%",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "aitk_evaluation_planner",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/nabsolutions.nab-al-tools-1.44.0",
    "publisher": "nabsolutions",
    "name": "nab-al-tools",
    "displayName": "NAB AL Tools",
    "version": "1.44.0",
    "package_json": "/home/kai/.vscode/extensions/nabsolutions.nab-al-tools-1.44.0/package.json",
    "tools": [
      {
        "name": "refreshXlf",
        "displayName": "Refresh an XLF file from a generated XLF file",
        "modelDescription": "This tool refreshes and synchronizes a XLF language file using the generated XLF file. It takes two parameters: the path to the generated XLF file (named <appname>.g.xlf) and the path to the target XLF file to be refreshed. The tool synchronizes the target XLF file with the latest changes from the generated file by preserving existing translations while adding new translation units from the generated file. It maintains the state of translated units and sorts the file according to the g.xlf structure. This synchronization process ensures that the translation file stays up-to-date with the latest AL code changes without losing existing translation work.",
        "tags": [
          "xliff",
          "translation",
          "localization",
          "internationalization",
          "al",
          "business-central",
          "dynamics-365"
        ],
        "userDescription": "(beta) This tool refreshes a XLF language file using a generated XLF file (g.xlf).",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "refreshXlf",
        "inputSchema": {
          "type": "object",
          "properties": {
            "generatedXlfFilePath": {
              "type": "string",
              "description": "The absolute path to the generated XLF file. The file is named '[app name].g.xlf', and the app name can be found in the app.json file. Example: For the app called 'My App', the generated Xlf file will be named 'My App.g.xlf'. This file is found in the Translations folder, which is the same folder as the target XLF file. This g.xlf file is automatically created and/or updated during AL compilation. Note that this file is often added to .gitignore, so you may need to show hidden and ignored files to find it."
            },
            "filePath": {
              "type": "string",
              "description": "The absolute path to the XLF file to refresh"
            }
          },
          "required": ["generatedXlfFilePath", "filePath"]
        }
      },
      {
        "name": "getTextsToTranslate",
        "displayName": "Get texts to translate from an XLF file",
        "modelDescription": "This tool retrieves untranslated texts from a specified XLF file. It returns a JSON object containing: texts (array of translation objects with id, source text, source language, context, maxLength, and comments), totalUntranslatedCount (the total number of untranslated texts in the file), and returnedCount (the number of texts returned in this batch). Each text object includes: id (unique identifier), source text (to be translated), source language, context (describes the context of what is being translated, such as 'Table Customer - Field Name - Property Caption' or 'Page Sales Order - Action Post - Property Caption'), maxLength (character limit if applicable), and contextual comments (explains placeholders like %1, %2, %3 etc.). The context field provides crucial context by identifying the specific AL object (table, page, codeunit, etc.), element (field, action, control), and property (caption, tooltip, etc.) being translated, enabling more accurate and contextually appropriate translations. The totalUntranslatedCount and returnedCount fields help track overall translation progress and pagination. This tool streamlines the translation workflow by identifying which texts need translation and providing comprehensive context for accurate localization.",
        "tags": [
          "xliff",
          "translation",
          "localization",
          "internationalization",
          "al",
          "business-central",
          "dynamics-365"
        ],
        "userDescription": "(beta) This tool retrieves untranslated texts from a specified XLF file.",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "getTextsToTranslate",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute path to the XLF file from which untranslated texts will be extracted."
            },
            "offset": {
              "type": "number",
              "description": "The starting position (zero-based index) for retrieving results. Used for pagination to skip a specific number of translation units before returning results."
            },
            "limit": {
              "type": "number",
              "description": "The maximum number of untranslated texts to return. Set to 0 to retrieve all available texts."
            },
            "sourceLanguageFilePath": {
              "type": "string",
              "description": "Optional. The absolute path to an alternative source language file. When specified, target texts from this file will be used as 'source' in the response. Useful for translating between similar languages (e.g., Swedish, Danish, Norwegian) instead of always using en-US as the source."
            }
          },
          "required": ["filePath", "limit"]
        }
      },
      {
        "name": "getTranslatedTextsMap",
        "displayName": "Get Translated Texts Map from an XLF file",
        "modelDescription": "This tool retrieves previously translated texts from a specified XLF file as a translation map. It returns a JSON array of translation objects, each containing: sourceText (the original text), targetTexts (an array of one or more translated versions), and sourceLanguage. This unique format groups all translations by their source text, which is particularly useful when the same source text has been translated differently in various contexts or has multiple acceptable translations. For example: {'sourceText': 'Total', 'targetTexts': ['Total', 'Totalt'], 'sourceLanguage': 'en-US'}. This tool helps maintain translation consistency by providing access to existing translation patterns and terminology variations, allowing you to reference previously translated phrases and understand translation choices when working on new content.",
        "tags": [
          "xliff",
          "translation",
          "localization",
          "internationalization",
          "al",
          "business-central",
          "dynamics-365"
        ],
        "userDescription": "(beta) This tool retrieves translated texts from a specified XLF file.",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "getTranslatedTextsMap",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute path to the XLF file from which to retrieve translated texts. This file should contain translation units with completed target elements."
            },
            "offset": {
              "type": "number",
              "description": "The starting position (zero-based index) for retrieving results. Used for pagination to skip a specific number of translation units before returning results."
            },
            "limit": {
              "type": "number",
              "description": "The maximum number of translated texts to return in a single request. Controls result set size for pagination. Set to 0 to retrieve all available translations."
            },
            "sourceLanguageFilePath": {
              "type": "string",
              "description": "Optional. The absolute path to an alternative source language file. When specified, target texts from this file will be used as 'source' in the response. Particularly useful when translating between similar languages (e.g., Swedish, Danish, Norwegian) instead of always using en-US as the source."
            }
          },
          "required": ["filePath", "limit"]
        }
      },
      {
        "name": "getTextsByKeyword",
        "displayName": "Get Texts By Keyword from an XLF file",
        "modelDescription": "This tool searches source or target texts in a specified XLF file for a given keyword or regular expression and returns matching translation units. By default, it searches in source texts (includes untranslated units). When searchInTarget is true, it searches only in target texts (excludes untranslated units). Use this to discover how a specific word or phrase is used across the application and to inspect how it has been translated in different contexts.",
        "tags": ["dynamics-365"],
        "userDescription": "(beta) Search source or target texts by keyword or regex in an XLF file. Use this to discover where a word or phrase appears and how it has been translated across contexts.",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "getTextsByKeyword",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute path to the XLF file to search."
            },
            "offset": {
              "type": "number",
              "description": "The starting position (zero-based index) for retrieving results. Used for pagination to skip a specific number of translation units before returning results."
            },
            "limit": {
              "type": "number",
              "description": "The maximum number of texts to return in a single request. Set to 0 to retrieve all available translations."
            },
            "keyword": {
              "type": "string",
              "description": "The keyword or regex pattern to search for in the source or target text."
            },
            "caseSensitive": {
              "type": "boolean",
              "description": "Enable case-sensitive matching (default false)."
            },
            "isRegex": {
              "type": "boolean",
              "description": "Treat the 'keyword' parameter as a regular expression (default false)."
            },
            "searchInTarget": {
              "type": "boolean",
              "description": "Search in target text instead of source text (default false). When true, only translated units with matching target text are returned."
            }
          },
          "required": ["filePath", "limit", "keyword"]
        }
      },
      {
        "name": "getTranslatedTextsByState",
        "displayName": "Get Translated Texts By State from an XLF file",
        "modelDescription": "This tool retrieves translated texts from a specified XLF file, filtered by their translation state. It returns a JSON array of objects containing: id (unique identifier), source text, source language, target text, context (describes the context of what is being translated, such as 'Table Customer - Field Name - Property Caption' or 'Page Sales Order - Action Post - Property Caption'), translation state, review reason (if available), maxLength (character limit if applicable), and contextual comments (explains placeholders like %1, %2, %3 etc.). The context field provides crucial context by identifying the specific AL object (table, page, codeunit, etc.), element (field, action, control), and property (caption, tooltip, etc.) being translated, enabling better understanding of existing translations and their business context. This tool streamlines the translation workflow by allowing you to filter translations by their state (e.g., 'needs-review', 'translated', 'final', 'signed-off') and providing comprehensive context for accurate localization.",
        "tags": [
          "xliff",
          "translation",
          "localization",
          "internationalization",
          "al",
          "business-central",
          "dynamics-365"
        ],
        "userDescription": "(beta) This tool retrieves translated texts from a specified XLF file, filtered by their translation state.",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "getTranslatedTextsByState",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute path to the XLF file from which to retrieve translated texts. This file should contain translation units with translated target elements."
            },
            "offset": {
              "type": "number",
              "description": "The starting position (zero-based index) for retrieving results. Used for pagination to skip a specific number of translation units before returning results."
            },
            "limit": {
              "type": "number",
              "description": "The maximum number of translated texts to return in a single request. Controls result set size for pagination. Set to 0 to retrieve all available translations."
            },
            "translationStateFilter": {
              "type": "string",
              "description": "The translation state to filter the results by. This can be one of the following: 'needs-review' (returns all translations that need review), 'translated' (completed translations), 'final' (finalized translations), or 'signed-off' (approved translations). If not specified, translations in all states will be returned.",
              "enum": ["needs-review", "translated", "final", "signed-off"]
            },
            "sourceText": {
              "type": "string",
              "description": "Optional. Filter results to only include translations that match this exact source text. This is particularly useful for: 1) Finding all translations of a specific phrase or term across different contexts, 2) Reviewing translation consistency for repeated text, 3) Updating all occurrences of a specific source text during translation review. For example, use 'Customer' to find all translations where the source text is exactly 'Customer', or 'Enter a value' to find translations of that specific instruction text."
            },
            "sourceLanguageFilePath": {
              "type": "string",
              "description": "Optional. The absolute path to an alternative source language file. When specified, target texts from this file will be used as 'source' in the response. Particularly useful when translating between similar languages (e.g., Swedish, Danish, Norwegian) instead of always using en-US as the source."
            }
          },
          "required": ["filePath", "limit"]
        }
      },
      {
        "name": "saveTranslatedTexts",
        "displayName": "Save Translation to an XLF file",
        "modelDescription": "This tool writes translated texts to a specified XLF file. It accepts an array of translation objects, each containing a unique identifier and the translated text to be saved. For optimal performance, submit multiple translations in a single batch rather than making individual calls. This tool enables efficient updating of XLF files with new or revised translations, maintaining the integrity of the XLIFF format while updating only the specified translation units.",
        "tags": [
          "xliff",
          "translation",
          "localization",
          "internationalization",
          "al",
          "business-central",
          "dynamics-365"
        ],
        "userDescription": "(beta) This tool saves a translation to a specified XLF file.",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "saveTranslatedTexts",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute path to the existing XLF file where translations should be saved. The file must already contain the translation units with source texts that correspond to the translations being provided."
            },
            "translations": {
              "type": "array",
              "description": "An array of translation objects to be saved to the XLF file. Each object must contain both the unique identifier of the translation unit and the translated text to be inserted.",
              "items": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "string",
                    "description": "The unique identifier of the translation unit in the XLF file. This ID must match an existing translation unit in the file."
                  },
                  "targetText": {
                    "type": "string",
                    "description": "The translated text to be saved as the target content for the specified translation unit. This will replace any existing target text for the given unit."
                  },
                  "targetState": {
                    "type": "string",
                    "description": "The target state of the translation unit. This can be one of the following: 'needs-review-translation', 'translated', 'final', 'signed-off'. If not specified, the target state will be 'translated' (or nothing, if not working with target states).",
                    "enum": [
                      "needs-review-translation",
                      "translated",
                      "final",
                      "signed-off"
                    ]
                  }
                },
                "required": ["id", "targetText"]
              }
            }
          },
          "required": ["filePath", "translations"]
        }
      },
      {
        "name": "createLanguageXlf",
        "displayName": "Create Target Language XLF File",
        "modelDescription": "This tool creates a new XLF file for a specified target language based on a generated XLF file. It takes a generated XLF file path (*.g.xlf), a target language code, and optional parameters to match translations from the base app. The tool creates a new XLF file ready for translation, optionally pre-populated with matching translations from Microsoft's base application. This streamlines the localization workflow by providing a foundation for translating AL extensions to new languages.",
        "tags": [
          "xliff",
          "translation",
          "localization",
          "internationalization",
          "al",
          "business-central",
          "dynamics-365"
        ],
        "userDescription": "(beta) This tool creates a new XLF file for a specified target language.",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "createLanguageXlf",
        "inputSchema": {
          "type": "object",
          "properties": {
            "generatedXlfFilePath": {
              "type": "string",
              "description": "The absolute path to the generated XLF file (*.g.xlf) created by AL compilation. This file is found in the Translations folder and is automatically created during AL compilation."
            },
            "targetLanguageCode": {
              "type": "string",
              "description": "Language code for the new XLF file (e.g., 'sv-SE', 'da-DK', 'de-DE')."
            },
            "matchBaseAppTranslation": {
              "type": "boolean",
              "description": "Whether to match translations from the base app (default: true). When enabled, the tool will pre-populate the new XLF file with matching translations from Microsoft's base application."
            }
          },
          "required": ["generatedXlfFilePath", "targetLanguageCode"]
        }
      },
      {
        "name": "getGlossaryTerms",
        "displayName": "Get Glossary Terminology",
        "modelDescription": "This tool returns glossary terminology pairs for a target language (and optional source language, default en-US) from a built-in glossary, based on Business Central terminology and translations. It outputs a JSON array of objects with 'source', 'target', and 'description'. Usage scenarios: (1) Pre-translation session - fetch glossary to instruct the LLM for consistent terminology. (2) Automated suggestion generation - validate/adjust outputs against approved terms. (3) Review/QA - detect and highlight deviations from glossary entries. (4) Bulk alignment or terminology normalization workflows. (5) Cross-language comparison by specifying a non-default sourceLanguageCode.",
        "tags": [
          "glossary",
          "terminology",
          "translation",
          "localization",
          "al",
          "business-central",
          "dynamics-365"
        ],
        "userDescription": "(beta) Retrieve glossary terminology entries for a specified target language.",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "getGlossaryTerms",
        "inputSchema": {
          "type": "object",
          "properties": {
            "targetLanguageCode": {
              "type": "string",
              "description": "Target language code for which glossary entries should be returned.",
              "enum": [
                "en-US",
                "cs-CZ",
                "da-DK",
                "de-AT",
                "de-CH",
                "de-DE",
                "en-AU",
                "en-CA",
                "en-GB",
                "en-NZ",
                "es-ES_tradnl",
                "es-MX",
                "fi-FI",
                "fr-BE",
                "fr-CA",
                "fr-CH",
                "fr-FR",
                "is-IS",
                "it-CH",
                "it-IT",
                "nb-NO",
                "nl-BE",
                "nl-NL",
                "sv-SE"
              ]
            },
            "sourceLanguageCode": {
              "type": "string",
              "description": "Optional source language code (default en-US) used as the source terminology column.",
              "enum": [
                "en-US",
                "cs-CZ",
                "da-DK",
                "de-AT",
                "de-CH",
                "de-DE",
                "en-AU",
                "en-CA",
                "en-GB",
                "en-NZ",
                "es-ES_tradnl",
                "es-MX",
                "fi-FI",
                "fr-BE",
                "fr-CA",
                "fr-CH",
                "fr-FR",
                "is-IS",
                "it-CH",
                "it-IT",
                "nb-NO",
                "nl-BE",
                "nl-NL",
                "sv-SE"
              ]
            }
          },
          "required": ["targetLanguageCode"]
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/prisma.prisma-31.1.0",
    "publisher": "Prisma",
    "name": "prisma",
    "displayName": "Prisma",
    "version": "31.1.0",
    "package_json": "/home/kai/.vscode/extensions/prisma.prisma-31.1.0/package.json",
    "tools": [
      {
        "name": "prisma-migrate-status",
        "tags": [
          "prisma",
          "database",
          "migrations",
          "postgres",
          "mysql",
          "sqlite"
        ],
        "toolReferenceName": "prisma-migrate-status",
        "displayName": "Prisma Migrate Status",
        "modelDescription": "The prisma migrate status command looks up the migrations in ./prisma/migrations/* folder and the entries in the _prisma_migrations table and compiles information about the state of the migrations in your database.\nUse this tool instead of running `prisma migrate status` on the CLI.\nExample output:\n\nStatus\n3 migrations found in prisma/migrations\n\nYour local migration history and the migrations table from your database are different:\n\nThe last common migration is: 20201127134938_new_migration\n\nThe migration have not yet been applied:\n20201208100950_test_migration\n\nThe migrations from the database are not found locally in prisma/migrations:\n20201208100950_new_migration",
        "userDescription": "The `prisma migrate status` command looks up the migration status of your database.",
        "canBeReferencedInPrompt": true,
        "icon": "./prisma_icon.svg",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectCwd": {
              "type": "string",
              "description": "The current working directory of the user's project. This should be the top level directory of the project but in a monorepo setup could also be a specific package or app directory."
            }
          }
        }
      },
      {
        "name": "prisma-migrate-dev",
        "tags": [
          "prisma",
          "database",
          "migrations",
          "postgres",
          "mysql",
          "sqlite"
        ],
        "toolReferenceName": "prisma-migrate-dev",
        "displayName": "Prisma Migrate Dev",
        "modelDescription": "Prisma Migrate Dev is used to update Prisma whenever the schema.prisma file has been modified.\nUse this tool instead of running `prisma migrate dev` on the CLI.\nAlways provide a descriptive name argument describing the change that was made to the Prisma Schema.\nThe migrate dev command performs these steps:\n1. Reruns the existing migration history in the shadow database in order to detect schema drift (edited or deleted migration file, or a manual changes to the database schema)\n2. Applies pending migrations to the shadow database (for example, new migrations created by colleagues)\n3. Generates a new migration from any changes you made to the Prisma schema before running migrate dev\n4. Applies all unapplied migrations to the development database and updates the _prisma_migrations table\n5. Triggers the generation of artifacts (for example, Prisma Client)",
        "userDescription": "`prisma migrate dev` is used to create a new migration and update your local database state whenever the schema.prisma file has been modified.",
        "canBeReferencedInPrompt": true,
        "icon": "./prisma_icon.svg",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectCwd": {
              "type": "string",
              "description": "The current working directory of the user's project. This should be the top level directory of the project but in a monorepo setup could also be a specific package or app directory."
            },
            "name": {
              "type": "string",
              "description": "A descriptive name argument that will be used in the name of the migration."
            }
          }
        }
      },
      {
        "name": "prisma-migrate-reset",
        "tags": [
          "prisma",
          "database",
          "migrations",
          "postgres",
          "mysql",
          "sqlite"
        ],
        "toolReferenceName": "prisma-migrate-reset",
        "displayName": "Prisma Migrate Reset",
        "modelDescription": "Prisma Migrate Reset is used to reset the database and migration history if drift is detected.\nUse this tool instead of running `prisma migrate reset --force` on the CLI.\nOnly run this command on a development database - never on production databases! If in doubt, ask the user to confirm.\nThe migrate reset command performs these steps:\n1. Drops the database/schema if possible, or performs a soft reset if the environment does not allow deleting databases/schemas\n2. Creates a new database/schema with the same name if the database/schema was dropped\n3. Applies all migrations\n4. Runs seed scripts",
        "userDescription": "`prisma migrate reset --force` is used to reset the database and migration history if drift is detected. Only run this command on a development database - never on production databases!",
        "canBeReferencedInPrompt": true,
        "icon": "./prisma_icon.svg",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectCwd": {
              "type": "string",
              "description": "The current working directory of the user's project. This should be the top level directory of the project but in a monorepo setup could also be a specific package or app directory."
            }
          }
        }
      },
      {
        "name": "prisma-studio",
        "tags": ["prisma", "database", "postgres", "mysql", "sqlite"],
        "toolReferenceName": "prisma-studio",
        "displayName": "Prisma Studio",
        "modelDescription": "Open Prisma Studio to view data in your database in a pleasing visual ui.\nUse this tool instead of running `prisma studio` on the CLI.\nProvide the current working directory of the users project. This should be the top level directory of the project.",
        "userDescription": "Open Prisma Studio to view data in your database in a pleasing visual ui.",
        "canBeReferencedInPrompt": true,
        "icon": "./prisma_icon.svg",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectCwd": {
              "type": "string",
              "description": "The current working directory of the user's project. This should be the top level directory of the project but in a monorepo setup could also be a specific package or app directory."
            }
          }
        }
      },
      {
        "name": "prisma-platform-login",
        "tags": ["prisma", "database", "ppg", "postgres"],
        "toolReferenceName": "prisma-platform-login",
        "displayName": "Prisma Platform Login",
        "modelDescription": "Login or create an account in order to be able to use Prisma Postgres.",
        "userDescription": "Login or create an account in order to be able to use Prisma Postgres.",
        "canBeReferencedInPrompt": true,
        "icon": "./prisma_icon.svg"
      },
      {
        "name": "prisma-postgres-create-database",
        "tags": ["prisma", "database", "ppg", "postgres"],
        "toolReferenceName": "prisma-postgres-create-database",
        "displayName": "Prisma Postgres Create Database",
        "modelDescription": "Create a new online Prisma Postgres database.\nSpecify a name that makes sense to the user - maybe the name of the project they are working on.\nSpecify a region that makes sense for the user. Pick between these options: us-east-1, eu-west-3, ap-northeast-1, ap-southeast-1 or call the tool without a region to get an up-to-date list of available regions. If you are unsure, pick us-east-1.\n\nIf the response indicates that you have reached the workspace plan limit, you should instruct the user to do one of these things:\nIf they want to connect to an existing database, they should go to console.prisma.io and copy the connection string\nIf they want to upgrade their plan, they should go to console.prisma.io and upgrade their plan in order to be able to create more databases\nIf they want to delete a database they no longer need, they should go to console.prisma.io and delete the database project.\nIf the user is not logged in, you should suggest them to login via the `prisma-platform-login` tool.",
        "userDescription": "Create a new online Prisma Postgres database.",
        "canBeReferencedInPrompt": true,
        "icon": "./prisma_icon.svg",
        "inputSchema": {
          "type": "object",
          "properties": {
            "workspaceId": {
              "type": "string",
              "description": "The id of workspace in which the new database shall be created. You can leave this blank if you don't have a prisma workspace id. The tool will prompt you provide you with a list of workspaces should the user have multiple workspaces."
            },
            "name": {
              "type": "string",
              "description": "The name for the new database."
            },
            "regionId": {
              "type": "string",
              "description": "The region for the new database. If you do not specify a region the tool will return a list of available regions and prompt you to specify one of them."
            }
          },
          "required": ["name"]
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/quantum.qsharp-lang-vscode-1.22.0",
    "publisher": "quantum",
    "name": "qsharp-lang-vscode",
    "displayName": "Azure Quantum Development Kit (QDK)",
    "version": "1.22.0",
    "package_json": "/home/kai/.vscode/extensions/quantum.qsharp-lang-vscode-1.22.0/package.json",
    "tools": [
      {
        "name": "azure-quantum-get-jobs",
        "tags": ["azure-quantum", "qsharp", "qdk"],
        "toolReferenceName": "azureQuantumGetJobs",
        "displayName": "Get Azure Quantum Jobs",
        "modelDescription": "Get a list of recent jobs that have been run by the customer, along with their statuses, in the currently active workspace. Call this when you need to know what jobs have been run recently or need a history of jobs run, for example when a customer asks 'What are my recent jobs?'",
        "canBeReferencedInPrompt": true,
        "icon": "./resources/file-icon-light.svg",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": [],
          "additionalProperties": false
        }
      },
      {
        "name": "azure-quantum-get-job",
        "tags": ["azure-quantum", "qsharp", "qdk"],
        "toolReferenceName": "azureQuantumGetJob",
        "displayName": "Get Azure Quantum Job Details",
        "modelDescription": "Get the job information for a customer's job given its id. Call this whenever you need to know information about a specific job, for example when a customer asks 'What is the status of my job?'",
        "canBeReferencedInPrompt": true,
        "icon": "./resources/file-icon-light.svg",
        "inputSchema": {
          "type": "object",
          "properties": {
            "job_id": {
              "type": "string",
              "description": "Job's unique identifier."
            }
          },
          "required": ["job_id"],
          "additionalProperties": false
        }
      },
      {
        "name": "azure-quantum-connect-to-workspace",
        "tags": ["azure-quantum", "qsharp", "qdk"],
        "toolReferenceName": "azureQuantumConnectToWorkspace",
        "displayName": "Connect to Azure Quantum Workspace",
        "modelDescription": "Starts the UI flow to connect to an existing Azure Quantum Workspace. Call this when the customer does not have an active workspace, and agrees to connect to a workspace.",
        "canBeReferencedInPrompt": true,
        "icon": "./resources/file-icon-light.svg",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": [],
          "additionalProperties": false
        }
      },
      {
        "name": "azure-quantum-download-job-results",
        "tags": ["azure-quantum", "qsharp", "qdk"],
        "toolReferenceName": "azureQuantumDownloadJobResults",
        "displayName": "Download Azure Quantum Job Results",
        "modelDescription": "Download and display the results from a customer's job given its id. Call this when you need to download or display as a histogram the results for a job, for example when a customer asks 'What are the results of my last job?' or 'Can you show me the histogram for this job?'",
        "canBeReferencedInPrompt": true,
        "icon": "./resources/file-icon-light.svg",
        "inputSchema": {
          "type": "object",
          "properties": {
            "job_id": {
              "type": "string",
              "description": "Job's unique identifier."
            }
          },
          "required": ["job_id"],
          "additionalProperties": false
        }
      },
      {
        "name": "azure-quantum-get-workspaces",
        "tags": ["azure-quantum", "qsharp", "qdk"],
        "toolReferenceName": "azureQuantumGetWorkspaces",
        "displayName": "Get Azure Quantum Workspaces",
        "modelDescription": "Get a list of workspaces the customer has access to, in the form of workspace ids. Call this when you need to know what workspaces the customer has access to, for example when a customer asks 'What are my workspaces?'",
        "canBeReferencedInPrompt": true,
        "icon": "./resources/file-icon-light.svg",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": [],
          "additionalProperties": false
        }
      },
      {
        "name": "azure-quantum-submit-to-target",
        "tags": ["azure-quantum", "qsharp", "qdk", "openqasm"],
        "toolReferenceName": "azureQuantumSubmitToTarget",
        "displayName": "Submit Program to Azure Quantum",
        "modelDescription": "Submits a Q# or OpenQASM program to Azure Quantum. The path to a .qs or .qasm file must be specified in the `filePath` parameter. The program will first be compiled to Quantum Intermediate Representation (QIR), and then submitted to run on the specified target.",
        "canBeReferencedInPrompt": true,
        "icon": "./resources/file-icon-light.svg",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute path to the .qs or .qasm file. If this file is part of a project, the whole project will be compiled as the program. A .qs file belongs to a project if it resides anywhere under a src/ directory whose parent directory also contains a qsharp.json manifest."
            },
            "jobName": {
              "type": "string",
              "description": "A name for the job."
            },
            "targetId": {
              "type": "string",
              "description": "The ID of the target to submit the job to, as returned by the azure-quantum-get-providers tool."
            },
            "shots": {
              "type": "number",
              "description": "The number of shots to use for the job."
            }
          },
          "required": ["filePath", "jobName", "targetId", "shots"],
          "additionalProperties": false
        }
      },
      {
        "name": "azure-quantum-get-active-workspace",
        "tags": ["azure-quantum", "qsharp", "qdk"],
        "toolReferenceName": "azureQuantumGetActiveWorkspace",
        "displayName": "Get Active Azure Quantum Workspace",
        "modelDescription": "Get the id of the active workspace for this conversation. Call this when you need to know what workspace is the active workspace being used in the context of the current conversation, for example when a customer asks 'What is the workspace that's being used?'",
        "canBeReferencedInPrompt": true,
        "icon": "./resources/file-icon-light.svg",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": [],
          "additionalProperties": false
        }
      },
      {
        "name": "azure-quantum-set-active-workspace",
        "tags": ["azure-quantum", "qsharp", "qdk"],
        "toolReferenceName": "azureQuantumSetActiveWorkspace",
        "displayName": "Set Active Azure Quantum Workspace",
        "modelDescription": "Set the active workspace for this conversation by id. Call this when you need to set what workspace is the active workspace being used in the context of the current conversation, for example when a customer says 'Please use this workspace for my requests.'",
        "canBeReferencedInPrompt": true,
        "icon": "./resources/file-icon-light.svg",
        "inputSchema": {
          "type": "object",
          "properties": {
            "workspace_id": {
              "type": "string",
              "description": "The id of the workspace to set as active."
            }
          },
          "required": ["workspace_id"],
          "additionalProperties": false
        }
      },
      {
        "name": "azure-quantum-get-providers",
        "tags": ["azure-quantum", "qsharp", "qdk"],
        "toolReferenceName": "azureQuantumGetProviders",
        "displayName": "Get Azure Quantum Providers",
        "modelDescription": "Get a list of hardware providers available to the customer, along with their provided targets. Call this when you need to know what providers or targets are available, for example when a customer asks 'What are the available providers?' or 'What targets do I have available?'",
        "canBeReferencedInPrompt": true,
        "icon": "./resources/file-icon-light.svg",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": [],
          "additionalProperties": false
        }
      },
      {
        "name": "azure-quantum-get-target",
        "tags": ["azure-quantum", "qsharp", "qdk"],
        "toolReferenceName": "azureQuantumGetTarget",
        "displayName": "Get Azure Quantum Target",
        "modelDescription": "Get the target information for a specified target given its id. Call this whenever you need to know information about a specific target, for example when a customer asks 'What is the status of this target?'",
        "canBeReferencedInPrompt": true,
        "icon": "./resources/file-icon-light.svg",
        "inputSchema": {
          "type": "object",
          "properties": {
            "target_id": {
              "type": "string",
              "description": "The ID of the target to get."
            }
          },
          "required": ["target_id"],
          "additionalProperties": false
        }
      },
      {
        "name": "qdk-run-program",
        "tags": ["azure-quantum", "qsharp", "qdk", "openqasm"],
        "toolReferenceName": "qdkRunProgram",
        "displayName": "Run Quantum Program",
        "modelDescription": "Executes a Q# or OpenQASM program. The path to a .qs or .qasm file must be specified in the `filePath` parameter. A quantum simulator will be run locally. Q# or OpenQASM do not provide any CLI tools, so call this tool whenever you need to execute code, instead of running any CLI commands. The `shots` parameter controls the number of times to repeat the simulation. If the number of shots is greater than 1, a histogram will be generated, and the results will be displayed in a dedicated panel.",
        "canBeReferencedInPrompt": true,
        "icon": "./resources/file-icon-light.svg",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute path to the .qs or .qasm file. If this file is part of a project, the whole project will be compiled as the program. A .qs file belongs to a project if it resides anywhere under a src/ directory whose parent directory also contains a qsharp.json manifest."
            },
            "shots": {
              "type": "number",
              "description": "The number of times to run the program. Defaults to 1 if not specified.",
              "default": 1
            }
          },
          "required": ["filePath"],
          "additionalProperties": false
        }
      },
      {
        "name": "qdk-generate-circuit",
        "tags": ["azure-quantum", "qsharp", "qdk", "openqasm"],
        "toolReferenceName": "qdkGenerateCircuit",
        "displayName": "Generate Quantum Circuit Diagram",
        "modelDescription": "Generates a visual circuit diagram for a Q# or OpenQASM program. The path to a .qs or .qasm file must be specified in the `filePath` parameter. This tool will compile the program and generate a quantum circuit diagram that visually represents the quantum operations in the code. If the program contains any dynamic behavior such as comparing measurement results, then the program will be executed using a quantum simulator, and the resulting circuit diagram will simply be a trace of the operations that were actually executed during simulation. The diagram will be displayed in a dedicated circuit panel.",
        "canBeReferencedInPrompt": true,
        "icon": "./resources/file-icon-light.svg",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute path to the .qs or .qasm file. If this file is part of a project, the whole project will be compiled as the program. A .qs file belongs to a project if it resides anywhere under a src/ directory whose parent directory also contains a qsharp.json manifest."
            }
          },
          "required": ["filePath"],
          "additionalProperties": false
        }
      },
      {
        "name": "qdk-run-resource-estimator",
        "tags": ["azure-quantum", "qsharp", "qdk", "openqasm"],
        "toolReferenceName": "qdkRunResourceEstimator",
        "displayName": "Run Quantum Resource Estimator",
        "modelDescription": "Runs the quantum resource estimator on a Q# or OpenQASM program to calculate the required physical resources. The path to a .qs or .qasm file must be specified in the `filePath` parameter. This tool will analyze the Q# program and generate estimates of the quantum resources required to run the algorithm, such as the number of qubits, T gates, and other quantum operations. Results will be displayed in a dedicated resource estimator panel.",
        "canBeReferencedInPrompt": true,
        "icon": "./resources/file-icon-light.svg",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute path to the .qs or .qasm file. If this file is part of a project, the whole project will be compiled as the program. A .qs file belongs to a project if it resides anywhere under a src/ directory whose parent directory also contains a qsharp.json manifest."
            },
            "qubitTypes": {
              "type": "array",
              "description": "Array of qubit type labels to use for resource estimation. Allowed values:\n- 'qubit_gate_ns_e3': Superconducting/spin qubit with 1e-3 error rate\n- 'qubit_gate_ns_e4': Superconducting/spin qubit with 1e-4 error rate\n- 'qubit_gate_us_e3': Trapped ion qubit with 1e-3 error rate\n- 'qubit_gate_us_e4': Trapped ion qubit with 1e-4 error rate\n- 'qubit_maj_ns_e4 + surface_code': Majorana qubit with 1e-4 error rate (surface code QEC)\n- 'qubit_maj_ns_e6 + surface_code': Majorana qubit with 1e-6 error rate (surface code QEC)\n- 'qubit_maj_ns_e4 + floquet_code': Majorana qubit with 1e-4 error rate (floquet code QEC)\n- 'qubit_maj_ns_e6 + floquet_code': Majorana qubit with 1e-6 error rate (floquet code QEC)",
              "items": {
                "type": "string",
                "enum": [
                  "qubit_gate_ns_e3",
                  "qubit_gate_ns_e4",
                  "qubit_gate_us_e3",
                  "qubit_gate_us_e4",
                  "qubit_maj_ns_e4 + surface_code",
                  "qubit_maj_ns_e6 + surface_code",
                  "qubit_maj_ns_e4 + floquet_code",
                  "qubit_maj_ns_e6 + floquet_code"
                ]
              },
              "default": ["qubit_gate_ns_e3"]
            },
            "errorBudget": {
              "type": "number",
              "description": "Error budget for the resource estimation. Must be a number between 0 and 1. Default is 0.001.",
              "minimum": 0,
              "maximum": 1,
              "default": 0.001
            }
          },
          "required": ["filePath"],
          "additionalProperties": false
        }
      },
      {
        "name": "qsharp-get-library-descriptions",
        "tags": ["azure-quantum", "qsharp", "qdk"],
        "toolReferenceName": "qsharpGetLibraryDescriptions",
        "displayName": "Get Q# Library API Descriptions",
        "modelDescription": "Returns a Markdown string summarizing all Q# standard library items, grouped by namespace. Each entry includes its signature and a short description extracted from doc comments when available. Use this tool to answer any questions about Q# library functions or to ensure generated Q# code uses library functions correctly.",
        "canBeReferencedInPrompt": true,
        "icon": "./resources/file-icon-light.svg",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": [],
          "additionalProperties": false
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/sonarsource.sonarlint-vscode-4.37.0",
    "publisher": "SonarSource",
    "name": "sonarlint-vscode",
    "displayName": "SonarQube for IDE",
    "version": "4.37.0",
    "package_json": "/home/kai/.vscode/extensions/sonarsource.sonarlint-vscode-4.37.0/package.json",
    "tools": [
      {
        "name": "sonarqube_list_potential_security_issues",
        "displayName": "SonarQube: List Potential Security Issues",
        "toolReferenceName": "sonarqube_getPotentialSecurityIssues",
        "canBeReferencedInPrompt": true,
        "icon": "$(unlock)",
        "modelDescription": "This tool returns a list of potential security issues (Security Hotspots and Taint Vulnerabilities) in a given file. It runs SonarQube analysis on the file and returns a list of Security Hotspots detected with their location and error message. Additionally, it lists Taint Vulnerabilities detected by SonarQube Server or Cloud analysis.",
        "tags": ["sonarqube", "security-analysis", "linter"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The full path to the file for which the potential security issues are to be listed."
            }
          }
        }
      },
      {
        "name": "sonarqube_exclude_from_analysis",
        "displayName": "SonarQube: Exclude File or Folder from Analysis",
        "toolReferenceName": "sonarqube_excludeFiles",
        "canBeReferencedInPrompt": true,
        "icon": "$(exclude)",
        "modelDescription": "This tool modifies the SonarQube for IDE configuration to exclude files matching a given glob pattern from analysis.",
        "tags": ["sonarqube", "static-analysis", "file-exclusion", "linter"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "globPattern": {
              "type": "string",
              "description": "Oracle glob pattern to exclude files or folders from analysis. For example, `**/test/**` to exclude all files in the test folder."
            }
          }
        }
      },
      {
        "name": "sonarqube_setup_connected_mode",
        "displayName": "SonarQube: Set up Connected Mode",
        "toolReferenceName": "sonarqube_setUpConnectedMode",
        "canBeReferencedInPrompt": true,
        "icon": "$(link)",
        "modelDescription": "This tool guides the user through the process of setting up Connected Mode in SonarQube for IDE. It provides instructions and prompts and runs necessary commands to help the user connect their IDE to a SonarQube Server or Cloud.",
        "tags": [
          "sonarqube",
          "sonarqube-connected-mode",
          "sonarcloud",
          "linter",
          "security-analysis"
        ],
        "inputSchema": {
          "type": "object",
          "properties": {
            "workspaceFolder": {
              "type": "string",
              "description": "Path to the workspace folder in VS Code for which the user wants to set up Connected Mode. If only one workspace folder is open, it will be used by default."
            },
            "isSonarQubeCloud": {
              "type": "boolean",
              "description": "Indicates whether the user wants to connect to SonarQube Cloud. If true, the user will be prompted for the organization key. If false, the user will be prompted for the server URL of their SonarQube Server."
            },
            "serverUrl": {
              "type": "string",
              "description": "URL of the SonarQube Server instance to connect to. Required if user wants to connect to a SonarQube Server. Example: `https://sonarqube.example.com`."
            },
            "organizationKey": {
              "type": "string",
              "description": "Key of the SonarQube Cloud organization to connect to. Required if user wants to connect to a SonarQube Cloud. Example: `my-organization`."
            },
            "projectKey": {
              "type": "string",
              "description": "Key of the SonarQube Server or Cloud project to bind to the workspace folder. This is used to set up the project binding in Connected Mode."
            }
          }
        }
      },
      {
        "name": "sonarqube_analyze_file",
        "displayName": "SonarQube: Analyze File",
        "toolReferenceName": "sonarqube_analyzeFile",
        "canBeReferencedInPrompt": true,
        "modelDescription": "This tool opens the requested file and runs SonarQube analysis on it. Detected code quality and security issues will be reported in the Problems view of the IDE. It can be used to analyze any file including those that are not part of a workspace or those that are excluded from the analysis. Do not call this method to analyze Jupyter Notebook.",
        "icon": "$(play)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The full path to the file that should be analyzed."
            }
          }
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/vscjava.migrate-java-to-azure-1.7.7-linux-x64",
    "publisher": "vscjava",
    "name": "migrate-java-to-azure",
    "displayName": "GitHub Copilot app modernization",
    "version": "1.7.7",
    "package_json": "/home/kai/.vscode/extensions/vscjava.migrate-java-to-azure-1.7.7-linux-x64/package.json",
    "tools": [
      {
        "name": "appmod-install-appcat",
        "tags": ["migration", "assessment"],
        "toolReferenceName": "appmod-install-appcat",
        "displayName": "Install AppCAT",
        "userDescription": "Installs the AppCAT CLI for Java application migration assessment.",
        "modelDescription": "Installs the AppCAT CLI for Java only if it is missing or outdated during the prerequisite check phase of assessment. After successful installation, proceed to initialize the Java application assessment process to check prerequisites. This tool is strictly limited to the pre-migration assessment preparation phase and must not be invoked during code migration workflows.",
        "canBeReferencedInPrompt": true,
        "when": "config.appmod.enableMcpServer != true",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "appmod-precheck-assessment",
        "tags": ["migration", "assessment"],
        "toolReferenceName": "appmod-precheck-assessment",
        "displayName": "Precheck Assessment",
        "userDescription": "Performs prerequisites verification and AppCAT CLI version checks for Java application assessment.",
        "modelDescription": "Performs prerequisites verification and AppCAT CLI version checks to initialize the Java application assessment process. Generates an assessment configuration for review. This tool is strictly limited to the pre-migration assessment phase and must not be invoked during code migration workflows.",
        "canBeReferencedInPrompt": true,
        "when": "config.appmod.enableMcpServer != true",
        "inputSchema": {
          "type": "object",
          "properties": {
            "workspacePath": {
              "type": "string",
              "description": "The workspace path of the Java project to assess"
            }
          },
          "required": ["workspacePath"]
        }
      },
      {
        "name": "appmod-run-assessment",
        "tags": ["migration", "assessment"],
        "toolReferenceName": "appmod-run-assessment",
        "displayName": "Run Assessment",
        "icon": "$(run)",
        "userDescription": "Executes assessment for the Java application to evaluate migration readiness.",
        "modelDescription": "Executes the AppCAT CLI for Java to assess the Java application. This tool is strictly limited to the pre-migration assessment phase and must not be invoked during code migration workflows.",
        "canBeReferencedInPrompt": true,
        "when": "config.appmod.enableMcpServer != true",
        "inputSchema": {
          "type": "object",
          "properties": {
            "workspacePath": {
              "type": "string",
              "description": "The workspace path of the Java project to assess"
            },
            "appCatConfig": {
              "type": "object",
              "description": "AppCAT configuration for assessment",
              "properties": {
                "target": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Target technologies. Valid values: azure-aks, azure-appservice, azure-container-apps, cloud-readiness, linux, openjdk11, openjdk17, openjdk21. Default is the target of AppCAT configuration in the Configuration Summary."
                },
                "mode": {
                  "type": "string",
                  "enum": ["source-only", "full"],
                  "description": "Analysis mode: source-only (analyze source code only) or full (analyze source code and list dependencies). Default is the mode of AppCAT configuration in the Configuration Summary."
                }
              }
            }
          },
          "required": ["workspacePath", "appCatConfig"]
        }
      },
      {
        "name": "appmod-get-vscode-config",
        "tags": ["migration", "configuration"],
        "toolReferenceName": "appmod-get-vscode-config",
        "displayName": "Get extension configuration",
        "userDescription": "Get configuration values for GitHub Copilot app modernization extension.",
        "modelDescription": "This tool retrieves extension configuration settings from VS Code. Use this tool when you need to check configuration values for the GitHub Copilot app modernization extension.",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "configName": {
              "type": "string",
              "description": "Name of the configuration setting to retrieve.",
              "examples": ["enableVerboseLogging", "uncommittedChangesAction"]
            }
          },
          "required": ["configName"]
        }
      },
      {
        "name": "appmod-preview-markdown",
        "tags": ["migration", "preview_markdown"],
        "toolReferenceName": "appmod-preview-markdown",
        "displayName": "Preview Markdown",
        "modelDescription": "This tool opens a preview of the given Markdown file.",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "markdownFile": {
              "type": "string",
              "description": "The absolute path to the Markdown file to preview and pinned to editor.",
              "examples": ["/absolute/path/to/README.md"]
            }
          }
        }
      },
      {
        "name": "appmod-validate-cve",
        "tags": ["migration", "cve_validate", "java"],
        "toolReferenceName": "appmod-validate-cve",
        "displayName": "Check the given Java dependencies have any known CVEs",
        "modelDescription": "(For Java application migration only) This tools checks if the given dependencies have any known vulnerabilities (CVEs). You MUST! use this tool to validate ALL the updated/added maven dependencies.",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "coordinates": {
              "type": "array",
              "description": "the coordinates of the dependencies to check for vulnerabilities. Each coordinate should be in the format of `groupId:artifactId:version`.",
              "examples": [
                "org.springframework:spring-core:5.3.9",
                "org.apache.commons:commons-lang3:3.12.0"
              ],
              "items": {
                "type": "string",
                "description": "The coordinate of a dependency to check for vulnerabilities, in the format of `groupId:artifactId:version`."
              }
            }
          }
        }
      },
      {
        "name": "migration_assessmentReport",
        "tags": ["migration", "assessment", "report", "follow_up_assessment"],
        "toolReferenceName": "migration_assessmentReport",
        "displayName": "Open Assessment Report",
        "userDescription": "Open the assessment report webview to display detailed migration analysis results.",
        "modelDescription": "This tool opens the assessment report webview interface to display detailed migration assessment results, including identified issues, recommendations, and Azure readiness analysis. Use this tool immediately after a successful migration assessment to show the results to the user. This is the recommended next step after running migration assessment.",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "uploadAssessSummaryReport",
        "tags": ["appcat"],
        "toolReferenceName": "uploadAssessSummaryReport",
        "displayName": "Upload Assessment Summary Report to GitHub Issue",
        "userDescription": "Upload the assessment summary report to github issue.",
        "modelDescription": "This tool upload the assessment summary report for the github issue after runnging the assessment.",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "description": "Input parameters for uploading the assessment summary report to a GitHub issue.",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)."
            },
            "repo": {
              "type": "string",
              "description": "Repository name."
            },
            "issueNumber": {
              "type": "number",
              "description": "Issue number to comment on."
            }
          },
          "required": ["owner", "repo", "issueNumber"]
        }
      },
      {
        "name": "appmod-build-project",
        "tags": ["migration", "build", "java"],
        "toolReferenceName": "appmod-build-project",
        "displayName": "Build Java Project",
        "userDescription": "(For Java application migration only) This tool uses Maven or Gradle to build your project and report any detected errors after migration. You should use this tool to verify after making code changes, and fix any errors found.",
        "modelDescription": "(For Java application migration only) This tool uses Maven or Gradle to build your project and report any detected errors after migration. You should use this tool to verify after making code changes, and fix any errors found.",
        "canBeReferencedInPrompt": true,
        "when": "config.appmod.enableMcpServer != true && !appmod.hasUpgradeBuildUtTool",
        "inputSchema": {
          "type": "object",
          "properties": {
            "workspacePath": {
              "type": "string",
              "description": "The workspace path for source code to be migrated"
            },
            "sessionId": {
              "type": "string",
              "description": "The session ID for tracking the migration process. This correlates operations across multiple tool calls in the same migration session."
            },
            "javaHome": {
              "type": "string",
              "description": "The absolute path of the appropriate JDK installation that can be found in the migration plan. You must set this parameter when a new JDK is installed during migration. It is JDK install path without bin"
            },
            "mavenHome": {
              "type": "string",
              "description": "The absolute path of the mvn/mvnw command location. If not using a wrapper, it MUST point to the MAVEN_HOME from the migration plan. If the project is using a wrapper, it is the workspace path. You must set this parameter when a new maven is installed during migration. It is maven install path without bin"
            }
          },
          "required": ["workspacePath", "sessionId"]
        }
      },
      {
        "name": "appmod-java-run-test",
        "tags": ["migration", "test", "java"],
        "toolReferenceName": "appmod-java-run-test",
        "displayName": "Run Java Tests",
        "userDescription": "This tool runs tests in the Java project and reports any detected errors or test failures after migration.",
        "modelDescription": "This tool runs tests in the Java project and reports any detected errors or test failures after migration.",
        "canBeReferencedInPrompt": true,
        "when": "config.appmod.enableMcpServer != true && !appmod.hasUpgradeBuildUtTool",
        "inputSchema": {
          "type": "object",
          "properties": {
            "workspacePath": {
              "type": "string",
              "description": "The workspace path for source code to be migrated"
            },
            "sessionId": {
              "type": "string",
              "description": "The session ID for tracking the migration process. This correlates operations across multiple tool calls in the same migration session."
            },
            "javaHome": {
              "type": "string",
              "description": "The absolute path of the appropriate JDK installation that can be found in the migration plan. You must set this parameter when a new JDK is installed during migration. It is JDK install path without bin"
            },
            "mavenHome": {
              "type": "string",
              "description": "The absolute path of the mvn/mvnw command location. If not using a wrapper, it MUST point to the MAVEN_HOME from the migration plan. If the project is using a wrapper, it is the workspace path. You must set this parameter when a new maven is installed during migration. It is maven install path without bin"
            }
          },
          "required": ["workspacePath", "sessionId"]
        }
      },
      {
        "name": "appmod-search-knowledgebase",
        "tags": ["migration", "knowledgebase", "search"],
        "toolReferenceName": "appmod-search-knowledgebase",
        "displayName": "Search Knowledge Base",
        "userDescription": "Searches the application modernization knowledge base using a query string. Returns relevant articles, documentation, and best practices. Use this tool to find information about app modernization strategies, migration paths, and common patterns.",
        "modelDescription": "Searches the application modernization knowledge base using a query string. Returns relevant articles, documentation, and best practices. Use this tool to find information about app modernization strategies, migration paths, and common patterns.",
        "canBeReferencedInPrompt": true,
        "when": "config.appmod.enableMcpServer != true",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The search query string to find relevant knowledge base."
            },
            "language": {
              "type": "string",
              "description": "The programming language to filter the knowledge base.",
              "enum": ["java", "python"],
              "default": "java"
            },
            "sessionId": {
              "type": "string",
              "description": "The session ID for tracking the migration process. This correlates operations across multiple tool calls in the same migration session."
            }
          },
          "required": ["query", "sessionId"]
        }
      },
      {
        "name": "appmod-search-file",
        "tags": ["migration", "file", "search"],
        "toolReferenceName": "appmod-search-file",
        "displayName": "Search Files",
        "userDescription": "Searches content from files in the project workspace by query and file patterns. Returns a list of files that match the search query. Use this tool to find specific code files or resources in your project based on patterns.",
        "modelDescription": "Searches content from files in the project workspace by query and file patterns. Returns a list of files that match the search query. Use this tool to find specific code files or resources in your project based on patterns.",
        "canBeReferencedInPrompt": true,
        "when": "config.appmod.enableMcpServer != true",
        "inputSchema": {
          "type": "object",
          "properties": {
            "workspacePath": {
              "type": "string",
              "description": "The path to the workspace where the search will be performed"
            },
            "query": {
              "type": "string",
              "description": "The query to search code lines from files. Could be regexp or string"
            },
            "includePattern": {
              "type": "string",
              "description": "Glob pattern to include files in the search, e.g., \"**/*.java\""
            },
            "sessionId": {
              "type": "string",
              "description": "The session ID for tracking the migration process. This correlates operations across multiple tool calls in the same migration session."
            }
          },
          "required": ["workspacePath", "query", "includePattern", "sessionId"]
        }
      },
      {
        "name": "appmod-fetch-knowledgebase",
        "tags": ["migration", "knowledgebase", "fetch"],
        "toolReferenceName": "appmod-fetch-knowledgebase",
        "displayName": "Fetch Knowledge Base",
        "userDescription": "Retrieves the complete content of a specific knowledge base article using its ID. Use this tool when you have a document ID and need to access its full content for detailed information about app modernization techniques.",
        "modelDescription": "Retrieves the complete content of a specific knowledge base article using its ID. Use this tool when you have a document ID and need to access its full content for detailed information about app modernization techniques.",
        "canBeReferencedInPrompt": true,
        "when": "config.appmod.enableMcpServer != true",
        "inputSchema": {
          "type": "object",
          "properties": {
            "kbId": {
              "type": "string",
              "description": "The ID of the knowledge base to retrieve. This is a unique identifier for the KB document."
            },
            "sessionId": {
              "type": "string",
              "description": "The session ID for tracking the migration process. This correlates operations across multiple tool calls in the same migration session."
            },
            "workspacePath": {
              "type": "string",
              "description": "The path to the workspace where the knowledge base content will be used."
            }
          },
          "required": ["kbId", "sessionId", "workspacePath"]
        }
      },
      {
        "name": "appmod-create-migration-summary",
        "tags": ["migration", "summary", "report"],
        "toolReferenceName": "appmod-create-migration-summary",
        "displayName": "Create Migration Summary",
        "userDescription": "(For migration only) Generates a summary for the migration session, including details about the migration scenario, task name, modified files, and the final status of build and test fix operations. This tool helps you document the migration process and its outcomes.",
        "modelDescription": "(For migration only) Generates a summary for the migration session, including details about the migration scenario, task name, modified files, and the final status of build and test fix operations. This tool helps you document the migration process and its outcomes.",
        "canBeReferencedInPrompt": true,
        "when": "config.appmod.enableMcpServer != true",
        "inputSchema": {
          "type": "object",
          "properties": {
            "kbIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The knowledge base ids which were used in code modifications. This is used to generate the migration summary."
            },
            "workspacePath": {
              "type": "string",
              "description": "The path to the workspace where the migration summary will be generated."
            },
            "sessionId": {
              "type": "string",
              "description": "The session ID for tracking the migration process. This correlates operations across multiple tool calls in the same migration session."
            },
            "status": {
              "type": "object",
              "description": "The migration status of the build, test, fix operations",
              "properties": {
                "buildFixStatus": {
                  "type": "object",
                  "description": "The status of the build fix operation, report only if the build fix tool is used, otherwise it will be set to unknown.",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": ["success", "fail", "unknown"],
                      "description": "The status of the report generation If it is not taken, it will be set to unknown."
                    },
                    "error": {
                      "type": "string",
                      "description": "An optional error message if the report generation failed."
                    }
                  },
                  "required": ["status"]
                },
                "testFixStatus": {
                  "type": "object",
                  "description": "The status of the test fix operation, report only if the test fix tool is used, otherwise it will be set to unknown.",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": ["success", "fail", "unknown"],
                      "description": "The status of the report generation If it is not taken, it will be set to unknown."
                    },
                    "error": {
                      "type": "string",
                      "description": "An optional error message if the report generation failed."
                    }
                  },
                  "required": ["status"]
                },
                "cveFixStatus": {
                  "type": "object",
                  "description": "The status of the CVE fix operation, report only if the CVE fix tool is used, otherwise it will be set to unknown.",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": ["success", "fail", "unknown"],
                      "description": "The status of the report generation If it is not taken, it will be set to unknown."
                    },
                    "error": {
                      "type": "string",
                      "description": "An optional error message if the report generation failed."
                    }
                  },
                  "required": ["status"]
                },
                "pythonSyntaxCheckStatus": {
                  "type": "object",
                  "description": "The status of the Python syntax check operation, report only if the Python syntax check tool is used, otherwise it will be set to unknown. ",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": ["success", "fail", "unknown"],
                      "description": "The status of the report generation If it is not taken, it will be set to unknown."
                    },
                    "error": {
                      "type": "string",
                      "description": "An optional error message if the report generation failed."
                    }
                  },
                  "required": ["status"]
                },
                "pythonLintCheckStatus": {
                  "type": "object",
                  "description": "The status of the Python lint check operation, report only if the Python lint check tool is used, otherwise it will be set to unknown.",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": ["success", "fail", "unknown"],
                      "description": "The status of the report generation If it is not taken, it will be set to unknown."
                    },
                    "error": {
                      "type": "string",
                      "description": "An optional error message if the report generation failed."
                    }
                  },
                  "required": ["status"]
                },
                "consistencyCheckStatus": {
                  "type": "object",
                  "description": "The status of the consistency fix operation, report only if the consistency validation tool is used, otherwise it will be set to unknown.",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": ["success", "fail", "unknown"],
                      "description": "The status of the report generation If it is not taken, it will be set to unknown."
                    },
                    "error": {
                      "type": "string",
                      "description": "An optional error message if the report generation failed."
                    },
                    "result": {
                      "type": "object",
                      "description": "Number of inconsistencies remaining after all fix attempts",
                      "properties": {
                        "critical": {
                          "type": "number",
                          "description": "Number of critical inconsistencies remaining after all fix attempts."
                        },
                        "major": {
                          "type": "number",
                          "description": "Number of major inconsistencies remaining after all fix attempts."
                        },
                        "minor": {
                          "type": "number",
                          "description": "Number of minor inconsistencies remaining after all fix attempts."
                        }
                      },
                      "required": ["critical", "major", "minor"]
                    }
                  },
                  "required": ["status", "result"]
                },
                "completenessCheckStatus": {
                  "type": "object",
                  "description": "The status of the completeness fix operation, report only if the completeness validation tool is used, otherwise it will be set to unknown.",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": ["success", "fail", "unknown"],
                      "description": "The status of the report generation If it is not taken, it will be set to unknown."
                    },
                    "error": {
                      "type": "string",
                      "description": "An optional error message if the report generation failed."
                    },
                    "result": {
                      "type": "object",
                      "description": "Number of completeness issues remaining after all fix attempts",
                      "properties": {
                        "issuesFound": {
                          "type": "number",
                          "description": "Number of completeness issues remaining after all fix attempts."
                        }
                      },
                      "required": ["issuesFound"]
                    }
                  },
                  "required": ["status", "result"]
                }
              },
              "required": [
                "buildFixStatus",
                "testFixStatus",
                "cveFixStatus",
                "pythonSyntaxCheckStatus",
                "pythonLintCheckStatus",
                "consistencyCheckStatus",
                "completenessCheckStatus"
              ]
            },
            "versionControlSummary": {
              "type": "object",
              "description": "Summary of version control activities during the migration process",
              "properties": {
                "versionControlSystem": {
                  "type": "string",
                  "description": "Version control system of workspace."
                },
                "branchName": {
                  "type": "string",
                  "description": "The name of the branch used for migration."
                },
                "commitCount": {
                  "type": "number",
                  "description": "Number of commits made during the migration process."
                },
                "hasUncommittedChanges": {
                  "type": "boolean",
                  "description": "Whether there are uncommitted changes in the workspace."
                }
              },
              "required": [
                "versionControlSystem",
                "commitCount",
                "hasUncommittedChanges"
              ]
            },
            "language": {
              "type": "string",
              "description": "The programming language of the project. Valid values are 'java' and 'python'."
            }
          },
          "required": [
            "kbIds",
            "workspacePath",
            "status",
            "sessionId",
            "versionControlSummary"
          ]
        }
      },
      {
        "name": "appmod-run-task",
        "tags": ["migration", "task", "execution"],
        "toolReferenceName": "appmod-run-task",
        "displayName": "Run Migration Task",
        "userDescription": "This tool will start a new migration session to run task based on given scenario or knowledge base id. This tool will provide a comprehensive migration plan, including steps to build the project, run tests, fix test failures, and more. It is designed to automate the migration process for the applications.",
        "modelDescription": "Run a migration task based on given migration scenario or knowledge base id. This tool will provide a comprehensive migration plan, including steps to build the project, run tests, fix test failures, and more. It is designed to automate the migration process for the applications.",
        "canBeReferencedInPrompt": true,
        "when": "config.appmod.enableMcpServer != true",
        "inputSchema": {
          "type": "object",
          "properties": {
            "kbId": {
              "type": "string",
              "description": "The knowledge base ID to use for the migration plan"
            },
            "taskId": {
              "type": "string",
              "description": "The ID of the task to be run"
            },
            "scenario": {
              "type": "string",
              "description": "The scenario for the migration plan"
            },
            "workspacePath": {
              "type": "string",
              "description": "The workspace path for source code to be migrated"
            },
            "language": {
              "type": "string",
              "description": "The programming language of the project. Valid values are 'java' and 'python'. This parameter is required to determine the appropriate migration strategy and tools to use."
            }
          },
          "required": ["workspacePath", "language"]
        }
      },
      {
        "name": "appmod-consistency-validation",
        "tags": ["migration", "validation", "consistency"],
        "toolReferenceName": "appmod-consistency-validation",
        "displayName": "Validate Migration Consistency",
        "userDescription": "This tool validates the consistency of migrated code by analyzing git diffs for any behavior changes. It identifies critical and major issues that need to be fixed to maintain functional equivalence between pre-migration and post-migration code.",
        "modelDescription": "This tool validates the consistency of migrated code by analyzing git diffs for any behavior changes. It identifies critical and major issues that need to be fixed to maintain functional equivalence between pre-migration and post-migration code.",
        "canBeReferencedInPrompt": true,
        "when": "config.appmod.enableMcpServer != true",
        "inputSchema": {
          "type": "object",
          "properties": {
            "workspacePath": {
              "type": "string",
              "description": "The workspace path for source code to be migrated"
            },
            "migrationScenario": {
              "type": "string",
              "description": "Description of the migration scenario being performed (e.g., 'ActiveMQ to Azure Service Bus', etc.). This helps provide context for the consistency validation process."
            },
            "kbIds": {
              "type": "array",
              "items": {
                "type": "string",
                "description": "The knowledge base ids which were used in code modifications. This is used to generate the migration summary."
              },
              "description": "The knowledge base ids which were used in code modifications. This is used to generate the migration summary."
            },
            "sessionId": {
              "type": "string",
              "description": "The session ID for tracking the migration process. This correlates operations across multiple tool calls in the same migration session."
            },
            "language": {
              "type": "string",
              "description": "The programming language of the project being migrated. Can be identified from migration plan file or progress tracking file.",
              "enum": ["java", "python"],
              "default": "java"
            },
            "baselineRevisionId": {
              "type": "string",
              "description": "The baseline git revision/commit ID to compare against for consistency validation. This is used to generate the git diff to analyze code changes."
            }
          },
          "required": [
            "workspacePath",
            "migrationScenario",
            "kbIds",
            "sessionId",
            "language",
            "baselineRevisionId"
          ]
        }
      },
      {
        "name": "appmod-completeness-validation",
        "tags": ["migration", "validation", "completeness"],
        "toolReferenceName": "appmod-completeness-validation",
        "displayName": "Validate Migration Completeness",
        "userDescription": "This tool validates migration completeness by systematically discovering old technology references that should have been migrated but were left unchanged. It generates detailed validation guidelines to identify missing removals and incomplete transformations across all files in the workspace.",
        "modelDescription": "This tool validates migration completeness by systematically discovering old technology references that should have been migrated but were left unchanged. It generates detailed validation guidelines to identify missing removals and incomplete transformations across all files in the workspace.",
        "canBeReferencedInPrompt": true,
        "when": "config.appmod.enableMcpServer != true",
        "inputSchema": {
          "type": "object",
          "properties": {
            "workspacePath": {
              "type": "string",
              "description": "The workspace path for source code to be migrated"
            },
            "migrationScenario": {
              "type": "string",
              "description": "Description of the migration scenario being performed (e.g., 'ActiveMQ to Azure Service Bus', etc.). This helps provide context for the completeness validation process."
            },
            "kbIds": {
              "type": "array",
              "items": {
                "type": "string",
                "description": "The knowledge base ids which were used in code modifications. This is used to generate the migration summary."
              },
              "description": "The knowledge base ids which were used in code modifications. This is used to generate the migration summary."
            },
            "sessionId": {
              "type": "string",
              "description": "The session ID for tracking the migration process. This correlates operations across multiple tool calls in the same migration session."
            },
            "language": {
              "type": "string",
              "description": "The programming language of the project being migrated. Can be identified from migration plan file or progress tracking file.",
              "enum": ["java", "python"],
              "default": "java"
            }
          },
          "required": [
            "workspacePath",
            "migrationScenario",
            "kbIds",
            "sessionId",
            "language"
          ]
        }
      },
      {
        "name": "appmod-version-control",
        "tags": ["migration", "versioncontrol", "execution"],
        "toolReferenceName": "appmod-version-control",
        "displayName": "Version Control Management",
        "userDescription": "This tool performs version control operations for migration projects, such as checking repository status, creating branches, committing changes, stashing changes, and managing uncommitted changes during the migration process.",
        "modelDescription": "This tool manages version control operations during migration. It supports checking repository status, creating branches, committing changes, stashing changes, discarding changes, and checking for uncommitted changes to ensure proper tracking of code changes throughout the migration process.",
        "canBeReferencedInPrompt": true,
        "when": "config.appmod.enableMcpServer != true",
        "inputSchema": {
          "type": "object",
          "properties": {
            "workspacePath": {
              "type": "string",
              "description": "The absolute path to the workspace where version control operations should be performed."
            },
            "action": {
              "type": "string",
              "enum": [
                "checkStatus",
                "createBranch",
                "commitChanges",
                "stashChanges",
                "discardChanges",
                "checkForUncommittedChanges"
              ],
              "description": "The version control action to perform. Available options: checkStatus (get repository status), createBranch (create new branch), commitChanges (commit all changes), stashChanges (stash working changes), discardChanges (discard all changes), checkForUncommittedChanges (check if workspace has uncommitted changes)."
            },
            "branchName": {
              "type": "string",
              "description": "The name of the branch to create. Optional parameter, but required when action is 'createBranch'."
            },
            "commitMessage": {
              "type": "string",
              "description": "The commit message to use. Optional parameter, but required when action is 'commitChanges'."
            },
            "stashMessage": {
              "type": "string",
              "description": "Message to include with stashed changes. Completely optional, only used when action is 'stashChanges'."
            }
          },
          "required": ["workspacePath", "action"]
        }
      },
      {
        "name": "appmod-python-setup-env",
        "tags": ["migration", "validation", "environment", "python"],
        "toolReferenceName": "appmod-python-setup-env",
        "displayName": "Setup Development Environment",
        "userDescription": "This tool sets up a Python virtual environment in the specified workspace. It creates a virtual environment, installs dependencies from requirements.txt and pyproject.toml if available, and ensures the environment is ready for Python development and testing.",
        "modelDescription": "This tool sets up a Python virtual environment in the specified workspace. It creates a virtual environment, installs dependencies from requirements.txt and pyproject.toml if available, and ensures the environment is ready for Python development and testing.",
        "canBeReferencedInPrompt": true,
        "when": "config.appmod.enableMcpServer != true && appmod.enablePythonMigration == true",
        "inputSchema": {
          "type": "object",
          "properties": {
            "workspacePath": {
              "type": "string",
              "description": "The workspace path for source code to be migrated"
            },
            "pythonInterpreter": {
              "type": "string",
              "description": "Specifies the Python interpreter path."
            }
          },
          "required": ["workspacePath", "pythonInterpreterPath"]
        }
      },
      {
        "name": "appmod-python-validate-syntax",
        "tags": ["migration", "validation", "syntax", "python"],
        "toolReferenceName": "appmod-python-validate-syntax",
        "displayName": "Check Python Syntax Issues",
        "userDescription": "This tool checks Python code syntax and fix any detected syntax errors after migration.",
        "modelDescription": "This tool checks Python code syntax and fix any detected syntax errors after migration.",
        "canBeReferencedInPrompt": true,
        "when": "config.appmod.enableMcpServer != true && appmod.enablePythonMigration == true",
        "inputSchema": {
          "type": "object",
          "properties": {
            "workspacePath": {
              "type": "string",
              "description": "The workspace path for source code to be migrated"
            },
            "pythonInterpreterPath": {
              "type": "string",
              "description": "The python interpreter in the created virtual environment. If not provided, the default path in '.venv' will be used."
            },
            "originalBranch": {
              "type": "string",
              "description": "The original branch before migration started."
            },
            "currentBranch": {
              "type": "string",
              "description": "The current branch after migration."
            }
          },
          "required": ["workspacePath"]
        }
      },
      {
        "name": "appmod-python-validate-lint",
        "tags": ["migration", "validation", "lint", "python"],
        "toolReferenceName": "appmod-python-validate-lint",
        "displayName": "Check Python Lint Issues",
        "userDescription": "This tool checks Python code linting issues and fix any detected linting issues after migration.",
        "modelDescription": "This tool checks Python code linting issues and fix any detected linting issues after migration.",
        "canBeReferencedInPrompt": true,
        "when": "config.appmod.enableMcpServer != true && appmod.enablePythonMigration == true",
        "inputSchema": {
          "type": "object",
          "properties": {
            "workspacePath": {
              "type": "string",
              "description": "The workspace path for source code to be migrated"
            },
            "pythonInterpreterPath": {
              "type": "string",
              "description": "The python interpreter in the created virtual environment. If not provided, the default path in '.venv' will be used."
            }
          },
          "required": ["workspacePath"]
        }
      },
      {
        "name": "appmod-python-run-test",
        "tags": ["migration", "validation", "test", "python"],
        "toolReferenceName": "appmod-python-run-test",
        "displayName": "Run Python Tests",
        "userDescription": "(For Python application migration only) This tool runs tests in the Python project and reports any detected errors or test failures after migration.",
        "modelDescription": "(For Python application migration only) This tool runs tests in the Python project and reports any detected errors or test failures after migration.",
        "canBeReferencedInPrompt": true,
        "when": "config.appmod.enableMcpServer != true && appmod.enablePythonMigration == true",
        "inputSchema": {
          "type": "object",
          "properties": {
            "workspacePath": {
              "type": "string",
              "description": "The workspace path for source code to be migrated"
            },
            "pythonInterpreterPath": {
              "type": "string",
              "description": "The python interpreter in '.venv'."
            }
          },
          "required": ["workspacePath"]
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/vscjava.vscode-java-upgrade-1.9.0",
    "publisher": "vscjava",
    "name": "vscode-java-upgrade",
    "displayName": "GitHub Copilot app modernization - upgrade for Java",
    "version": "1.9.0",
    "package_json": "/home/kai/.vscode/extensions/vscjava.vscode-java-upgrade-1.9.0/package.json",
    "tools": [
      {
        "name": "generate_upgrade_plan",
        "displayName": "Generate Upgrade Plan",
        "userDescription": "Generate a plan for upgrading a Java project",
        "icon": "assets/JavaUpgrade_16x.svg",
        "toolReferenceName": "generate_upgrade_plan",
        "canBeReferencedInPrompt": true,
        "modelDescription": "This tool is specifically designed to generate a professional, comprehensive and efficient plan for upgrading Java projects, and then starts a upgrade session (identified with a **session ID**) with the generated plan. Session ID is very important and MUST be passed to all the other tools contributed by this extension during an upgrade process, as it is used to track the upgrade process and store/retrieve context and state information. \nThis tool is the entry of an intelligent agent that is highly proficient in upgrading Java projects. This intelligent agent owns a set of other helpful tools to assist in the entire upgrade process and will guide the entire upgrade process by providing 'Next steps' information in these tools' result messages. You **MUST strictly** follow its instructions to complete the upgrade process. If 'Next steps' are provided, you **MUST** adhere to them precisely and not act on your own initiative; any unauthorized actions will be subject to severe penalties. This tool should be invoked at the beginning of an upgrade process. You MUST! invoke this tool whenever you need to upgrade a Java project.",
        "tags": [
          "java",
          "java-upgrade",
          "enable_other_tool_setup_development_environment_for_upgrade",
          "enable_other_tool_upgrade_java_project_using_openrewrite",
          "enable_other_tool_build_java_project",
          "enable_other_tool_validate_cves_for_java",
          "enable_other_tool_validate_behavior_changes_for_java",
          "enable_other_tool_run_tests_for_java",
          "enable_other_tool_summarize_upgrade"
        ],
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "The absolute path to the Java project to upgrade. This should be the root directory containing the project's build files (pom.xml or build.gradle)."
            },
            "jdkPath": {
              "type": "string",
              "description": "The absolute path to the JDK installation, which MUST match the project's current Java version (`javaVersion`) exactly, i.e. if the project is using Java 11, the JDK path must point to a JDK 11 installation. Leave this parameter empty if you can not find a JDK that exactly matches the project's current Java version. This tool will try to detect a valid JDK installed on the system automatically if not specified, and even install it if necessary."
            },
            "buildToolPath": {
              "type": "string",
              "description": "The absolute path to the build tool (e.g., Maven, Gradle) installation for the project specified by 'projectPath'. This tool will try to detect a build tool installed on the system if not specified, and even install it if necessary."
            },
            "targetJavaVersion": {
              "type": "string",
              "enum": ["8", "11", "17", "21", "25"],
              "description": "The target version of Java to upgrade to, allowed values are `8`, `11`, `17`, `21` and `25`. This parameter and `targetDependencies` should be set at least one of them, otherwise the tool will throw an error and ask you to set it. But you should only set this parameter when user explicitly asks to upgrade the Java version, otherwise you should leave it empty. you should never make assumptions about the target Java version to upgrade to."
            },
            "targetDependencies": {
              "type": "array",
              "description": "An array of dependencies (coordinates) to upgrade to. Each dependency should be in the format of `groupId:artifactId:version` or `groupId:*:version`. Use `groupId:*:version` format if you want to upgrade all artifacts of a group to the specified version. e.g., `org.springframework.boot:*:3.2.12` means upgrade all Spring Boot dependencies to version 3.2.12. Use `groupId:artifactId:version` to upgrade a specific artifact to a specific version, e.g. `org.apache.commons:commons-lang3:3.17.0` means upgrade the `commons-lang3` artifact of the `org.apache.commons` group to version 3.17.0. **For Spring Boot (group id: `org.springframework.boot`), the allowed versions are `2.7.x`, `3.2.x`, `3.3.x`, `3.4.x` or `3.5.x`. For Jakarta EE (group id: `jakarta.platform`), the allowed versions are `10.0.x`. For Spring Framework (group id: `org.springframework`), the allowed versions are `6.1.x` and `6.2.x`.** For other dependencies, any version is acceptable. If user hasn't specified the version of target dependency, you should use the latest allowed version, e.g, `3.5.x` for Spring Boot, `10.0.x` for Jakarta EE and `6.2.x` for Spring Framework. You should also use the latest patch version whenever possible. If you're unable to determine the coordinates (i.e. `groupId:artifactId:version`) of the dependency to be upgraded based solely on the user's input, you can ask user to clarify or analyze the project first in combination with the user's input to identify the correct coordinates. This parameter and `targetJavaVersion` should be set at least one of them, otherwise the tool will throw an error and ask you to set it. But you should only set this parameter when user explicitly asks to upgrade the dependencies, otherwise you should leave it empty. You should never make assumptions about the target dependencies to upgrade to.",
              "items": {
                "type": "string",
                "description": "dependency (coordinates) to upgrade to, in the format of `groupId:artifactId:version` or `groupId:*:version`. Use `groupId:*:version` format if you want to upgrade all artifacts of a group to the specified version. e.g., `org.springframework.boot:*:3.2.12` means upgrade all Spring Boot dependencies to version 3.2.12. Use `groupId:artifactId:version` to upgrade a specific artifact to a specific version, e.g. `org.apache.commons:commons-lang3:3.17.0` means upgrade the `commons-lang3` artifact of the `org.apache.commons` group to version 3.17.0. **For Spring Boot (group id: `org.springframework.boot`), the allowed versions are `2.7.x`, `3.2.x`, `3.3.x`, `3.4.x` or `3.5.x`. For Jakarta EE (group id: `jakarta.platform`), the allowed versions are `10.0.x`. For Spring Framework (group id: `org.springframework`), the allowed versions are `6.1.x` and `6.2.x`.** For other dependencies, any version is acceptable. If user hasn't specified the version of target dependency, you should use the latest allowed version, e.g, `3.5.x` for Spring Boot, `10.0.x` for Jakarta EE and `6.2.x` for Spring Framework. You should also use the latest patch version whenever possible. If you're unable to determine the coordinates (i.e. `groupId:artifactId:version`) of the dependency to be upgraded based solely on the user's input, you can ask user to clarify or analyze the project first in combination with the user's input to identify the correct coordinates."
              }
            },
            "targetJdkPath": {
              "type": "string",
              "description": "The absolute path to the JDK installation, which MUST matches the `targetJavaVersion` exactly, i.e. if the `targetJavaVersion` is `21`, the JDK path must point to a JDK 21 installation. Leave this parameter empty if you can not find a JDK that exactly matches the `targetJavaVersion`. This tool will try to detect a valid JDK installed on the system automatically if not specified, and even install it if necessary."
            },
            "useCurrentBranch": {
              "type": "boolean",
              "description": "Whether to use the current Git branch as the working branch for the upgrade. All changes will be committed to the current branch if set to true; otherwise, the changes will be committed to a newly auto-created branch. You should set this to true ONLY when the user explicitly requests to reuse the current branch, set it to false or leave it unset otherwise."
            },
            "guidelines": {
              "type": "string",
              "description": "Any specific guidelines or constraints for the upgrade process provided by the user, should be in the form of a markdown bulleted list. Be careful that \"Guidelines\" should focus only on **HOW** to perform the upgrade. Leave this parameter empty if no specific guidelines or constraints provided by the user, and you should never make assumptions about any guidelines or constraints."
            }
          },
          "required": ["projectPath"]
        }
      },
      {
        "name": "generate_upgrade_plan_no_sampling",
        "displayName": "Generate Upgrade Plan",
        "userDescription": "Generate a plan for upgrading a Java project",
        "icon": "assets/JavaUpgrade_16x.svg",
        "toolReferenceName": "generate_upgrade_plan",
        "canBeReferencedInPrompt": true,
        "modelDescription": "This tool is specifically designed to generate a professional, comprehensive and efficient plan for upgrading Java projects, and then starts a upgrade session (identified with a **session ID**) with the generated plan. Session ID is very important and MUST be passed to all the other tools contributed by this extension during an upgrade process, as it is used to track the upgrade process and store/retrieve context and state information. \nThis tool is the entry of an intelligent agent that is highly proficient in upgrading Java projects. This intelligent agent owns a set of other helpful tools to assist in the entire upgrade process and will guide the entire upgrade process by providing 'Next steps' information in these tools' result messages. You **MUST strictly** follow its instructions to complete the upgrade process. If 'Next steps' are provided, you **MUST** adhere to them precisely and not act on your own initiative; any unauthorized actions will be subject to severe penalties. This tool should be invoked at the beginning of an upgrade process. You MUST! invoke this tool whenever you need to upgrade a Java project.",
        "tags": [
          "java",
          "java-upgrade",
          "enable_other_tool_setup_development_environment_for_upgrade",
          "enable_other_tool_upgrade_java_project_using_openrewrite",
          "enable_other_tool_build_java_project",
          "enable_other_tool_validate_cves_for_java",
          "enable_other_tool_run_tests_for_java",
          "enable_other_tool_summarize_upgrade"
        ],
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "The absolute path to the Java project to upgrade. This should be the root directory containing the project's build files (pom.xml or build.gradle)."
            },
            "jdkPath": {
              "type": "string",
              "description": "The absolute path to the JDK installation, which MUST match the project's current Java version (`javaVersion`) exactly, i.e. if the project is using Java 11, the JDK path must point to a JDK 11 installation. Leave this parameter empty if you can not find a JDK that exactly matches the project's current Java version. This tool will try to detect a valid JDK installed on the system automatically if not specified, and even install it if necessary."
            },
            "buildToolPath": {
              "type": "string",
              "description": "The absolute path to the build tool (e.g., Maven, Gradle) installation for the project specified by 'projectPath'. This tool will try to detect a build tool installed on the system if not specified, and even install it if necessary."
            },
            "targetJavaVersion": {
              "type": "string",
              "enum": ["8", "11", "17", "21", "25"],
              "description": "The target version of Java to upgrade to, allowed values are `8`, `11`, `17`, `21` and `25`. This parameter and `targetDependencies` should be set at least one of them, otherwise the tool will throw an error and ask you to set it. But you should only set this parameter when user explicitly asks to upgrade the Java version, otherwise you should leave it empty. you should never make assumptions about the target Java version to upgrade to."
            },
            "targetDependencies": {
              "type": "array",
              "description": "An array of dependencies (coordinates) to upgrade to. Each dependency should be in the format of `groupId:artifactId:version` or `groupId:*:version`. Use `groupId:*:version` format if you want to upgrade all artifacts of a group to the specified version. e.g., `org.springframework.boot:*:3.2.12` means upgrade all Spring Boot dependencies to version 3.2.12. Use `groupId:artifactId:version` to upgrade a specific artifact to a specific version, e.g. `org.apache.commons:commons-lang3:3.17.0` means upgrade the `commons-lang3` artifact of the `org.apache.commons` group to version 3.17.0. **For Spring Boot (group id: `org.springframework.boot`), the allowed versions are `2.7.x`, `3.2.x`, `3.3.x`, `3.4.x` or `3.5.x`. For Jakarta EE (group id: `jakarta.platform`), the allowed versions are `10.0.x`. For Spring Framework (group id: `org.springframework`), the allowed versions are `6.1.x` and `6.2.x`.** For other dependencies, any version is acceptable. If user hasn't specified the version of target dependency, you should use the latest allowed version, e.g, `3.5.x` for Spring Boot, `10.0.x` for Jakarta EE and `6.2.x` for Spring Framework. You should also use the latest patch version whenever possible. If you're unable to determine the coordinates (i.e. `groupId:artifactId:version`) of the dependency to be upgraded based solely on the user's input, you can ask user to clarify or analyze the project first in combination with the user's input to identify the correct coordinates. This parameter and `targetJavaVersion` should be set at least one of them, otherwise the tool will throw an error and ask you to set it. But you should only set this parameter when user explicitly asks to upgrade the dependencies, otherwise you should leave it empty. You should never make assumptions about the target dependencies to upgrade to.",
              "items": {
                "type": "string",
                "description": "dependency (coordinates) to upgrade to, in the format of `groupId:artifactId:version` or `groupId:*:version`. Use `groupId:*:version` format if you want to upgrade all artifacts of a group to the specified version. e.g., `org.springframework.boot:*:3.2.12` means upgrade all Spring Boot dependencies to version 3.2.12. Use `groupId:artifactId:version` to upgrade a specific artifact to a specific version, e.g. `org.apache.commons:commons-lang3:3.17.0` means upgrade the `commons-lang3` artifact of the `org.apache.commons` group to version 3.17.0. **For Spring Boot (group id: `org.springframework.boot`), the allowed versions are `2.7.x`, `3.2.x`, `3.3.x`, `3.4.x` or `3.5.x`. For Jakarta EE (group id: `jakarta.platform`), the allowed versions are `10.0.x`. For Spring Framework (group id: `org.springframework`), the allowed versions are `6.1.x` and `6.2.x`.** For other dependencies, any version is acceptable. If user hasn't specified the version of target dependency, you should use the latest allowed version, e.g, `3.5.x` for Spring Boot, `10.0.x` for Jakarta EE and `6.2.x` for Spring Framework. You should also use the latest patch version whenever possible. If you're unable to determine the coordinates (i.e. `groupId:artifactId:version`) of the dependency to be upgraded based solely on the user's input, you can ask user to clarify or analyze the project first in combination with the user's input to identify the correct coordinates."
              }
            },
            "targetJdkPath": {
              "type": "string",
              "description": "The absolute path to the JDK installation, which MUST matches the `targetJavaVersion` exactly, i.e. if the `targetJavaVersion` is `21`, the JDK path must point to a JDK 21 installation. Leave this parameter empty if you can not find a JDK that exactly matches the `targetJavaVersion`. This tool will try to detect a valid JDK installed on the system automatically if not specified, and even install it if necessary."
            },
            "useCurrentBranch": {
              "type": "boolean",
              "description": "Whether to use the current Git branch as the working branch for the upgrade. When set to true, all changes will be committed to the current branch. When set to false or unset, changes will be committed to a newly auto-created branch. Set this to true in two scenarios: (1) when the user explicitly requests to reuse the current branch, or (2) when running within the GitHub Coding Agent environment (required). Otherwise, set to false or leave unset."
            },
            "guidelines": {
              "type": "string",
              "description": "Any specific guidelines or constraints for the upgrade process provided by the user, should be in the form of a markdown bulleted list. Be careful that \"Guidelines\" should focus only on **HOW** to perform the upgrade. Leave this parameter empty if no specific guidelines or constraints provided by the user, and you should never make assumptions about any guidelines or constraints."
            }
          },
          "required": ["projectPath"]
        }
      },
      {
        "name": "confirm_upgrade_plan",
        "displayName": "Review Plan",
        "userDescription": "Review the generated plan for upgrading the Java project",
        "icon": "assets/JavaUpgrade_16x.svg",
        "toolReferenceName": "confirm_upgrade_plan",
        "canBeReferencedInPrompt": true,
        "modelDescription": "This tool displays the plan generated by the `generate_upgrade_plan` tool in the editor area, allowing users to make adjustments to the plan and confirm before execution. You should invoke this tool immediately after the plan is generated to ask user to confirm. This tool should only be invoked during an upgrade process.",
        "tags": ["java", "java-upgrade"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "The ID of the upgrade session to which the plan needing confirmation belongs. This should be the session ID generated by the `generate_upgrade_plan` tool."
            }
          },
          "required": ["sessionId"]
        }
      },
      {
        "name": "setup_upgrade_environment",
        "displayName": "Setup Development Environment",
        "userDescription": "Setup the development environment for upgrading the Java project",
        "icon": "assets/JavaUpgrade_16x.svg",
        "toolReferenceName": "setup_upgrade_environment",
        "canBeReferencedInPrompt": true,
        "modelDescription": "This tool sets up the development environment required for the upgrade, including the build tool and at least two JDKs. These two JDKs are used to build the project before and after the upgrade, respectively. Here is how the tool works: \n1. The tool reads all necessary information from the 'plan.md' generated by tool `generate_upgrade_plan`. \n2. This tool will first detect compatible build tools and JDKs installed on the local machine automatically if they are not provided in the 'plan.md'; \n3. This tool will throw an exception to ask user to provide them manually if not detected.\n Be careful: \n- If the user provides any information in the conversation, you MUST make sure to write it into the appropriate place in 'plan.md' by yourself first because this tool only reads all information from 'plan.md'. \n- You MUST re-invoke this tool for these changes to take effect whether the user manually modifies 'plan.md' or you modify it. This tool should only be invoked during an upgrade process.",
        "tags": ["java", "java-upgrade"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "The ID of the upgrade session to which the plan needing confirmation belongs. This should be the session ID generated by the `generate_upgrade_plan` tool."
            }
          },
          "required": ["sessionId"]
        }
      },
      {
        "name": "setup_upgrade_environment_no_sampling",
        "displayName": "Setup Development Environment",
        "userDescription": "Setup the development environment for upgrading the Java project",
        "icon": "assets/JavaUpgrade_16x.svg",
        "toolReferenceName": "setup_upgrade_environment",
        "canBeReferencedInPrompt": true,
        "modelDescription": "This tool sets up the development environment required for the upgrade, including the build tool and at least two JDKs. These two JDKs are used to build the project before and after the upgrade, respectively. You MUST read the 'plan.md' generated by tool `generate_upgrade_plan`, parse the input parameters based on its content and then call this tool. Here is how the tool works: \n1. The tool accept parameters parsed from plan.md. \n2. This tool will detect compatible build tools and JDKs installed on the local machine automatically if they are not provided in the 'plan.md'; \n3. This tool will throw an exception to ask user to provide them manually if not detected.\n Be careful: \n- If the user provides any information in the conversation, you MUST make sure to write it into the appropriate place in 'plan.md' by yourself first because this tool only reads all information from 'plan.md'. \n- You MUST re-invoke this tool for these changes to take effect whether the user manually modifies 'plan.md' or you modify it. This tool should only be invoked during an upgrade process.",
        "tags": ["java", "java-upgrade"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "The ID of the upgrade session to which the plan needing confirmation belongs. This should be the session ID generated by the `generate_upgrade_plan` tool."
            },
            "name": {
              "type": "string",
              "description": "The name of the project. Must match the value labeled 'Project name' in the 'plan.md' file. Example: my-java-project."
            },
            "dir": {
              "type": "string",
              "description": "Absolute path to the project directory. Must match the value labeled 'Project path' in the 'plan.md' file. Example (Windows): C:\\Users\\user\\workspace\\my-java-project."
            },
            "jdkPath": {
              "type": "string",
              "description": "Source JDK installation path. Use empty string if the value was '<to be installed, or specify the path here>' in 'plan.md'."
            },
            "jdkVersion": {
              "type": "string",
              "description": "Original Java version of the project (major or full semantic form if available)."
            },
            "buildToolType": {
              "type": "string",
              "enum": ["mvn", "mvnw", "gradle", "gradlew"],
              "description": "Name of the build tool, should be parsed from the value of 'Build tool type' in 'plan.md'. e.g., mvn, mvnw, gradle, gradlew indicates Maven, Maven Wrapper, Gradle, Gradle Wrapper respectively."
            },
            "buildToolPath": {
              "type": "string",
              "description": "path of the build tool, should be the value of 'Build tool path' in 'plan.md'. You must leave it empty string if it's '<to be installed, or specify the path here>'"
            },
            "buildToolDefaultOptions": {
              "type": "string",
              "description": "Additional options that can be passed to the build tool executable. Should be the value of 'Build tool command options' in 'plan.md'."
            },
            "targetJavaVersion": {
              "type": "string",
              "description": "The target Java version to upgrade to, should be parsed from the 'Upgrade Goals' block. You MUST! leave it empty if there is no mention about the Java version in the text."
            },
            "targetJdkPath": {
              "type": "string",
              "description": "Path to the JDK installation to use after the upgrade, should be the value of 'Target JDK path'. You must leave it empty string if it's '<to be installed, or specify the path here>'"
            },
            "targetDependencyCoordinates": {
              "type": "array",
              "description": " target dependencies/Java version to upgrade to. should be parsed from the 'Upgrade Goals' block. please leave it empty if there is no mention about the dependencies in the text.",
              "items": {
                "type": "string",
                "description": "dependency (in the format of `groupId:artifactId:version`, e.g. `org.apache.commons:commons-lang3:3.12.0`)."
              }
            },
            "workingBranch": {
              "type": "string",
              "description": "Git working branch name, should be the value of 'Working branch'. e.g., appmod/java-upgrade-20231010123456."
            },
            "runTests": {
              "type": "boolean",
              "description": "whether to run tests before and after the upgrade. Should be the value of 'Run tests before and after the upgrade'. e.g., true."
            }
          },
          "required": [
            "sessionId",
            "name",
            "dir",
            "jdkVersion",
            "buildToolType",
            "targetJavaVersion",
            "targetJdkPath",
            "targetDependencyCoordinates"
          ]
        }
      },
      {
        "name": "precheck_for_upgrade",
        "displayName": "Pre-Check",
        "userDescription": "Review the generated plan for upgrading the Java project",
        "icon": "assets/JavaUpgrade_16x.svg",
        "toolReferenceName": "precheck_for_upgrade",
        "canBeReferencedInPrompt": false,
        "modelDescription": "This tool performs a set of pre-checks for the upgrade plan, ensuring that all necessary conditions are met before proceeding with the upgrade. It should be invoked before the actual upgrade process begins. This tool is intended for internal use only, you should NEVER invoke this tool directly.",
        "tags": ["java", "java-upgrade"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "The ID of the upgrade session to which the plan needing confirmation belongs. This should be the session ID generated by the `generate_upgrade_plan` tool."
            }
          },
          "required": ["sessionId"]
        }
      },
      {
        "name": "upgrade_using_openrewrite",
        "displayName": "Upgrade Using OpenRewrite",
        "userDescription": "Upgrade the Java project using OpenRewrite",
        "icon": "assets/JavaUpgrade_16x.svg",
        "toolReferenceName": "upgrade_using_openrewrite",
        "canBeReferencedInPrompt": true,
        "modelDescription": "This tool ONLY supports upgrading JDK to up to 21, Spring Boot to up to 3.3.x, Spring Framework to up to 6.1.x and Jakarta EE to up to 10.0.x using OpenRewrite. Be careful: \n- This tool ONLY supports upgrading JDK, Spring Boot, Spring Framework and JEE to limited versions, This tool will only make limited initial changes for upgrading, so the project will not be fully upgraded and even not buildable after this tool is invoked. This tool should only be invoked during an upgrade process. \n- You MUST NOT invoke this tool if you are not upgrading upgrading JDK version, SpringBoot, Spring Framework or JEE.\n- You MUST NOT invoke this tool if you want to apply specific OpenRewrite recipes, you may run maven or gradle command instead.\n- You MUST ONLY invoke this tool when you are explicitly asked to even when you are upgrading this technologies. ",
        "tags": ["java", "java-upgrade"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "The ID of the upgrade session to which the plan needing confirmation belongs. This should be the session ID generated by the `generate_upgrade_plan` tool."
            }
          },
          "required": ["sessionId"]
        }
      },
      {
        "name": "build_java_project",
        "displayName": "Build Project",
        "userDescription": "Build Java project to check status",
        "icon": "assets/JavaUpgrade_16x.svg",
        "toolReferenceName": "build_java_project",
        "canBeReferencedInPrompt": true,
        "modelDescription": "This tool uses Maven or Gradle to build Java project and report any build errors. This tool detects the build tool and JDK smartly, so you SHOULD ALWAYS use this tool when you need to build a Java project or check the build status or configuration of a Java project. \nIf there are any new code changes made **since the last build**, You should analyze and summarize the code changes into a detailed description and then use it as input ('codeChanges') of this tool, but be careful not to include any changes that were made in previous builds. You MUST! always invoke this tool to check the build status of the project after making any code changes.",
        "tags": ["java"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "The id of the upgrade session during which this tool is invoked. This Session ID will be used to track the upgrade process and retrieve environment and state information like the project path, JDK path, and build tool path and it should be the one generated by the `generate_upgrade_plan` tool. This param is required if this tool is invoked inside an upgrade process, and MUST be omitted when invoked outside an upgrade process."
            },
            "projectPath": {
              "type": "string",
              "description": "The absolute path to the Java project to build and check build status for. This should be the root directory containing the project's build files. This param is always required."
            },
            "jdkPath": {
              "type": "string",
              "description": "The absolute path to the JDK installation, which matches the project's current Java version. This tool will try to detect a JDK installed on the system if not specified, and it will throw an error if no suitable JDK is detected or if the provided JDK does not match the project's current Java version. You should then invoke this tool again with a valid JDK path. This parameter MUST be omitted when this tool is invoked inside an upgrade process."
            },
            "buildToolPath": {
              "type": "string",
              "description": "The absolute path to the build tool (e.g., Maven, Gradle) installation for the project specified by 'projectPath'. This tool will try to detect a build tool installed on the system if not specified, and it will throw an error if no suitable build tool is detected or if the provided build tool does not match the project's current build tool. You should then invoke this tool again with a valid build tool path. This parameter MUST be omitted when this tool is invoked inside an upgrade process."
            },
            "codeChangesMessage": {
              "type": "string",
              "description": "The short description of the new code changes made since last build, this will be used a commit message of the code changes, so it should be a short summary of the changes made in only one sentence. e.g. 'Fix CVE-2023-1234 in org.springframework:spring-core:5.3.9'. Leave this parameter empty if there are no new code changes made since the last build or if this is the first build of the project. This parameter is required if there are any code changes made in the workspace."
            },
            "codeChangesDetails": {
              "type": "string",
              "description": "Markdown formatted detailed description of the code changes made since last build. This should be a 2-level bullet list, with the first level being the short description of the issue fixed or the feature added and the second level being the summarized description of the changes made to fix the issue or implement the feature. e.g. '- Fix CVE-2023-1234 in `org.springframework:spring-core`\n  - Upgrade `org.springframework:spring-core` to `x.y.z`'. Leave this parameter empty if there are no new code changes made since the last build or if this is the first build of the project. This parameter is required if there are new code changes made since the last build. be careful not to include any changes that were made in previous builds."
            }
          },
          "required": [
            "codeChangesMessage",
            "codeChangesDetails",
            "projectPath"
          ]
        }
      },
      {
        "name": "validate_cves_for_java",
        "displayName": "Check CVEs",
        "userDescription": "Check if the given Java dependencies have any known CVEs",
        "icon": "assets/JavaUpgrade_16x.svg",
        "toolReferenceName": "validate_cves_for_java",
        "canBeReferencedInPrompt": true,
        "modelDescription": "This tools checks if the given Java dependencies have any known vulnerabilities (CVEs). It will return a list of CVE issues found in the given dependencies, along with their severity and description. You MUST pass the dependencies to check as input, be careful that each dependency MUST be in the format of `groupId:artifactId:version`, e.g. `org.apache.commons:commons-lang3:3.12.0`. You must filter out any dependencies if you can not determine the version of them. You should use this tool to check for any known CVEs in the dependencies of the Java project",
        "tags": ["java"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "The id of the upgrade session during which this tool is invoked. This Session ID will be used to track the upgrade process and retrieve environment and state information like the project path and it should be the one generated by the `generate_upgrade_plan` tool. This param is required if this tool is invoked inside an upgrade process, and MUST be omitted when invoked outside an upgrade process."
            },
            "dependencies": {
              "type": "array",
              "description": "An array of Java dependencies to check for CVE issues. Each dependency should be in the format of `groupId:artifactId:version` (all the 3 parts, groupId, artifactId and version are required), e.g. `org.apache.commons:commons-lang3:3.12.0`. Filter out any dependencies if you can not determine the version of them. This param is required if `sessionId` is omitted.",
              "items": {
                "type": "string",
                "description": "dependency (in the format of `groupId:artifactId:version`, all the 3 parts, groupId, artifactId and version are required, e.g. `org.apache.commons:commons-lang3:3.12.0`) to check for CVE issues."
              }
            }
          }
        }
      },
      {
        "name": "validate_behavior_changes",
        "displayName": "Check Code Behavior Changes",
        "userDescription": "Check if logic behavior of modified code remains the same based on git diff between two commits",
        "icon": "assets/JavaUpgrade_16x.svg",
        "toolReferenceName": "validate_behavior_changes",
        "canBeReferencedInPrompt": true,
        "modelDescription": "This tool validates if changed code maintains the same logic functionality as before modifying using LLM. This tool takes 2 commits (`fromCommit` and `toCommit`) as input, and compares the code changes between them using `git diff ${fromCommit} ${toCommit}` to validate if the logic behavior of the modified code remains the same. but both commits can be omitted: if `fromCommit` is omitted, it will compare the current working tree with the last commit; if `toCommit` is omitted, it will compare the current working tree with the `fromCommit`. Code behavior is required to be the same in refactoring or upgrade process.",
        "tags": ["java"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "The id of the upgrade session during which this tool is invoked. This Session ID will be used to track the upgrade process and retrieve environment and state information like the project path and it should be the one generated by the `generate_upgrade_plan` tool. This param is required if this tool is invoked during an upgrade process, and MUST be omitted when invoked outside an upgrade process."
            },
            "projectPath": {
              "type": "string",
              "description": "The absolute path to the Java project to validate code behavior changes for. This should be the root directory containing the project's build files. This param is required if this tool is invoked outside an upgrade process, and it MUST be omitted when invoked inside an upgrade process."
            },
            "fromCommit": {
              "type": "string",
              "description": "the commit hash of the commit to compare from. If omitted, this tool will compare the current working tree with the last commit. This param MUST be omitted if this tool is invoked during an upgrade process."
            },
            "toCommit": {
              "type": "string",
              "description": "The commit hash of the commit to compare to. If omitted, this tool will compare the current working tree with the `fromCommit`. This param MUST be omitted if this tool is invoked during an upgrade process."
            }
          }
        }
      },
      {
        "name": "run_tests_for_java",
        "displayName": "Run Unit Tests",
        "userDescription": "Run tests in the Java project using the build tool",
        "icon": "assets/JavaUpgrade_16x.svg",
        "toolReferenceName": "run_tests_for_java",
        "canBeReferencedInPrompt": true,
        "modelDescription": "This tool runs test cases in the Java project using the build tool (e.g. Maven, Gradle) and reports any test errors/failures. This tool can be used to check the test status of the project.",
        "tags": ["java"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "The id of the upgrade session during which this tool is invoked. This Session ID will be used to track the upgrade process and retrieve environment and state information like the project path, JDK path, and build tool path and it should be the one generated by the `generate_upgrade_plan` tool. This param is required if this tool is invoked during an upgrade process, and MUST be omitted when invoked outside an upgrade process."
            },
            "projectPath": {
              "type": "string",
              "description": "The absolute path to the Java project to run tests for. This should be the root directory containing the project's build files. This param is always required."
            },
            "jdkPath": {
              "type": "string",
              "description": "The absolute path to the JDK installation, which matches the project's current Java version. This tool will try to detect a JDK installed on the system if not specified, and it will throw an error if no suitable JDK is detected or if the provided JDK does not match the project's current Java version. You should then invoke this tool again with a valid JDK path. This parameter MUST be omitted when this tool is invoked inside an upgrade process."
            },
            "buildToolPath": {
              "type": "string",
              "description": "The absolute path to the build tool (e.g., Maven, Gradle) installation for the project specified by 'projectPath'. This tool will try to detect a build tool installed on the system if not specified, and it will throw an error if no suitable build tool is detected or if the provided build tool does not match the project's current build tool. You should then invoke this tool again with a valid build tool path. This parameter MUST be omitted when this tool is invoked inside an upgrade process."
            }
          },
          "required": ["projectPath"]
        }
      },
      {
        "name": "summarize_upgrade",
        "displayName": "Summarize Upgrade",
        "userDescription": "Summarize all the changes made during an upgrade process and generate a markdown formatted summary",
        "icon": "assets/JavaUpgrade_16x.svg",
        "toolReferenceName": "summarize_upgrade",
        "canBeReferencedInPrompt": true,
        "modelDescription": "This tool summarize the whole upgrade process and all the changes made to upgrade the Java project, including the code changes, test cases generated, and any other relevant information. This tool should be invoked at the end of an upgrade process to summarize the entire upgrade process. It will generate a markdown formatted summary of the upgrade process, which can be used to document the upgrade process.",
        "tags": ["java", "java-upgrade"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "The id of the upgrade session during which this tool is invoked. This Session ID will be used to track the upgrade process and retrieve environment and state information and it should be the one generated by the `generate_upgrade_plan` tool. This param is required if this tool is invoked during an upgrade process, and MUST be omitted when invoked outside an upgrade process."
            }
          },
          "required": ["sessionId"]
        }
      },
      {
        "name": "generate_tests_for_java",
        "displayName": "Generate Unit Tests",
        "userDescription": "Generate unit test cases for the Java project using LLM",
        "icon": "assets/JavaUpgrade_16x.svg",
        "toolReferenceName": "generate_tests_for_java",
        "canBeReferencedInPrompt": true,
        "modelDescription": "This tool generates test cases for the Java classes of a Java project. This tool will iterate through all the Java classes in the project and generate test cases for each class, so it would be time consuming for large projects. The generated test cases will be placed in the same package as the original class, but with a `Test` suffix added to the class name.",
        "tags": ["java", "java-upgrade"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "The id of the upgrade session during which this tool is invoked. This Session ID will be used to track the upgrade process and retrieve environment and state information like the project path, JDK path, and build tool path and it should be the one generated by the `generate_upgrade_plan` tool. This param is required if this tool is invoked during an upgrade process, and MUST be omitted when invoked outside an upgrade process."
            },
            "projectPath": {
              "type": "string",
              "description": "The absolute path to the Java project to generate test cases. This should be the root directory containing the project's build files. This param is required if this tool is invoked outside an upgrade process, and MUST be omitted when invoked inside an upgrade process."
            },
            "jdkPath": {
              "type": "string",
              "description": "The absolute path to the JDK installation, which matches the project's current Java version. This tool will try to detect a JDK installed on the system if not specified, and it will throw an error if no suitable JDK is detected or if the provided JDK does not match the project's current Java version. You should then invoke this tool again with a valid JDK path. This parameter MUST be omitted when this tool is invoked inside an upgrade process."
            },
            "buildToolPath": {
              "type": "string",
              "description": "The absolute path to the build tool (e.g., Maven, Gradle) installation for the project specified by 'projectPath'. This tool will try to detect a build tool installed on the system if not specified, and it will throw an error if no suitable build tool is detected or if the provided build tool does not match the project's current build tool. You should then invoke this tool again with a valid build tool path. This parameter MUST be omitted when this tool is invoked inside an upgrade process."
            }
          }
        }
      },
      {
        "name": "list_jdks",
        "displayName": "List JDKs",
        "userDescription": "List all available JDKs on the system",
        "icon": "assets/JavaUpgrade_16x.svg",
        "toolReferenceName": "list_jdks",
        "canBeReferencedInPrompt": true,
        "modelDescription": "This tool lists available JDKs (Java Development Kits) on the system. It can be used to find installed JDKs path and version. The result will be in json format",
        "tags": ["java", "jdk"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "The id of the upgrade session during which this tool is invoked. This Session ID will be used to track the upgrade process and retrieve environment and state information like the project path, JDK path, and build tool path and it should be the one generated by the `generate_upgrade_plan` tool. This param is required if this tool is invoked during an upgrade process, and MUST be omitted when invoked outside an upgrade process."
            },
            "additionalSearchPaths": {
              "type": "array",
              "description": "An array of paths to search for JDK installations.",
              "items": {
                "type": "string",
                "description": "A path to search for JDK installations."
              }
            },
            "version": {
              "type": "string",
              "description": "The major version of JDK to search. If not specified, all versions will be listed."
            }
          }
        }
      },
      {
        "name": "list_mavens",
        "displayName": "List Mavens",
        "userDescription": "List all available Mavens on the system",
        "icon": "assets/JavaUpgrade_16x.svg",
        "toolReferenceName": "list_mavens",
        "canBeReferencedInPrompt": true,
        "modelDescription": "This tool lists all available Mavens (Apache Maven) on the system. It can be used to find installed Mavens path and version. The result will be in json format",
        "tags": ["java", "maven"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "The id of the upgrade session during which this tool is invoked. This Session ID will be used to track the upgrade process and retrieve environment and state information like the project path, JDK path, and build tool path and it should be the one generated by the `generate_upgrade_plan` tool. This param is required if this tool is invoked during an upgrade process, and MUST be omitted when invoked outside an upgrade process."
            },
            "additionalSearchPaths": {
              "type": "array",
              "description": "An array of paths to search for Maven installations.",
              "items": {
                "type": "string",
                "description": "A path to search for Maven installations."
              }
            },
            "includeVersion": {
              "type": "boolean",
              "default": false,
              "description": "Whether to include the version of Maven in the search, by default will be false. When set to true, it may take longer time."
            }
          }
        }
      },
      {
        "name": "install_jdk",
        "displayName": "Install JDK",
        "userDescription": "Install a specific version of JDK from the internet",
        "icon": "assets/JavaUpgrade_16x.svg",
        "toolReferenceName": "install_jdk",
        "canBeReferencedInPrompt": true,
        "modelDescription": "This tool installs a specific version of JDK (Java Development Kit) from the internet. It downloads and installs the JDK from a trusted source (Microsoft/Eclipse Adoptium) and returns the installation path. This tool can be used when you need to install a JDK for a Java project or when the required JDK version is not available on the system.",
        "tags": ["java", "jdk", "install"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "The id of the upgrade session during which this tool is invoked. This Session ID will be used to track the upgrade process and retrieve environment and state information like the project path, JDK path, and build tool path and it should be the one generated by the `generate_upgrade_plan` tool. This param is required if this tool is invoked during an upgrade process, and MUST be omitted when invoked outside an upgrade process."
            },
            "version": {
              "type": "string",
              "description": "The version of JDK to install, if not set, the latest LTS version will be installed."
            },
            "dest": {
              "type": "string",
              "description": "The absolute path to the directory where the JDK will be installed. If not provided, ~/.jdk will be used."
            }
          },
          "required": ["version"]
        }
      },
      {
        "name": "install_maven",
        "displayName": "Install Maven",
        "userDescription": "Install a specific version of Maven from the internet",
        "icon": "assets/JavaUpgrade_16x.svg",
        "toolReferenceName": "install_maven",
        "canBeReferencedInPrompt": true,
        "modelDescription": "This tool installs a specific version of Maven (a build automation tool for Java projects) from the internet. It downloads and installs Maven from a trusted source and returns the installation path. This tool can be used when you need to install Maven for a Java project or when the required Maven version is not available on the system.",
        "tags": ["java", "maven", "install"],
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "The id of the upgrade session during which this tool is invoked. This Session ID will be used to track the upgrade process and retrieve environment and state information like the project path, JDK path, and build tool path and it should be the one generated by the `generate_upgrade_plan` tool. This param is required if this tool is invoked during an upgrade process, and MUST be omitted when invoked outside an upgrade process."
            },
            "version": {
              "type": "string",
              "default": "latest",
              "enum": ["latest", "3.9.11", "3.8.9"],
              "description": "The version of Maven to install, supported values are 'latest', '3.9.11' and '3.8.9'"
            },
            "dest": {
              "type": "string",
              "description": "The absolute path to the directory where Maven will be installed. If not provided, ~/.maven will be used."
            }
          },
          "required": ["version"]
        }
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/wallabyjs.console-ninja-1.0.500",
    "publisher": "WallabyJs",
    "name": "console-ninja",
    "displayName": "Console Ninja",
    "version": "1.0.500",
    "package_json": "/home/kai/.vscode/extensions/wallabyjs.console-ninja-1.0.500/package.json",
    "tools": [
      {
        "name": "console_ninja_source_code_loader",
        "tags": ["source code"],
        "toolReferenceName": "console_ninja_source_code_loader",
        "displayName": "Console Ninja source code loader",
        "modelDescription": "Console Ninja source code loader",
        "icon": "$(files)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "description": "File path to get code from"
            }
          }
        },
        "when": "console-ninja.aiFeaturesEnabled"
      },
      {
        "name": "console_ninja_file_logs_loader",
        "tags": ["logs"],
        "toolReferenceName": "console_ninja_file_logs_loader",
        "displayName": "Console Ninja file logs loader",
        "modelDescription": "Console Ninja file logs loader",
        "icon": "$(json)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "description": "Path of the file to retrieve logs from"
            },
            "line": {
              "type": "integer",
              "optional": true,
              "description": "Specific line number to retrieve logs from (optional)"
            }
          }
        },
        "when": "console-ninja.aiFeaturesEnabled"
      },
      {
        "name": "console-ninja_runtimeErrors",
        "toolReferenceName": "console-ninja_runtimeErrors",
        "canBeReferencedInPrompt": true,
        "tags": ["errors"],
        "displayName": "Console Ninja runtime errors",
        "modelDescription": "Get application runtime errors. Includes errors from the browser (browser dev tools reported), and/or node server errors in the case of fullstack applications.",
        "icon": "$(bracket-error)",
        "when": "console-ninja.started"
      },
      {
        "name": "console-ninja_runtimeLogs",
        "toolReferenceName": "console-ninja_runtimeLogs",
        "canBeReferencedInPrompt": true,
        "tags": ["logs"],
        "displayName": "Console Ninja runtime logs",
        "modelDescription": "Get application runtime logs. Includes logs from the browser (browser dev tools reported), and/or node server logs in the case of fullstack applications.",
        "icon": "$(json)",
        "when": "console-ninja.started"
      },
      {
        "name": "console-ninja_runtimeLogsByLocation",
        "toolReferenceName": "console-ninja_runtimeLogsByLocation",
        "canBeReferencedInPrompt": true,
        "tags": ["logs"],
        "displayName": "Console Ninja runtime logs by location",
        "modelDescription": "Get application runtime logs for given file and line. Includes logs from the browser (browser dev tools reported), and/or node server logs in the case of fullstack applications.",
        "icon": "$(json)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "description": "File path of the file you are after logs in"
            },
            "line": {
              "type": "integer",
              "description": "Line number of the file you are after logs in"
            }
          }
        },
        "when": "console-ninja.started"
      },
      {
        "name": "console-ninja_runtimeLogsAndErrors",
        "toolReferenceName": "console-ninja_runtimeLogsAndErrors",
        "canBeReferencedInPrompt": true,
        "tags": ["logs", "errors"],
        "displayName": "Console Ninja runtime logs and errors",
        "modelDescription": "Get application runtime logs and errors. Includes both logs and errors from the browser (browser dev tools reported), and/or node server logs and errors in the case of fullstack applications.",
        "icon": "$(output)",
        "when": "console-ninja.started"
      }
    ]
  },
  {
    "extension_dir": "/home/kai/.vscode/extensions/wallabyjs.wallaby-vscode-1.0.482",
    "publisher": "WallabyJs",
    "name": "wallaby-vscode",
    "displayName": "Wallaby.js",
    "version": "1.0.482",
    "package_json": "/home/kai/.vscode/extensions/wallabyjs.wallaby-vscode-1.0.482/package.json",
    "tools": [
      {
        "name": "wallaby_codeWithCoverage",
        "tags": ["code", "coverage", "test coverage"],
        "toolReferenceName": "codeWithCoverage",
        "displayName": "Wallaby code coverage",
        "modelDescription": "Source code with coverage information",
        "icon": "$(files)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "description": "File path to get code with coverage from"
            }
          }
        },
        "when": "wallaby.aiFeaturesEnabled"
      },
      {
        "name": "wallaby_valueExplorer",
        "tags": ["runtime values"],
        "toolReferenceName": "valueExplorer",
        "displayName": "Wallaby runtime values",
        "modelDescription": "Runtime value at a specific line and column",
        "icon": "$(json)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "description": "File path to get runtime values from"
            },
            "line": {
              "type": "integer",
              "description": "Line number to get runtime values from"
            },
            "lineContent": {
              "type": "string",
              "description": "Full line text with the expression to get runtime values from"
            },
            "column": {
              "type": "integer",
              "description": "Column number to get runtime values from"
            },
            "expression": {
              "type": "string",
              "description": "Expression to get runtime values for"
            }
          }
        },
        "when": "wallaby.aiFeaturesEnabled"
      },
      {
        "name": "wallaby_runtimeValues",
        "tags": ["runtime values", "logs", "evaluation"],
        "displayName": "Runtime values",
        "modelDescription": "Get runtime value at a specific source code location. \n\nSupplied line number should be 1-based. When counting lines in a file, do count blank lines as well.\n\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "description": "File path to get runtime values from"
            },
            "line": {
              "type": "integer",
              "description": "Line number to get runtime values from"
            },
            "lineContent": {
              "type": "string",
              "description": "Full text of the line that contains the expression to get runtime values from"
            },
            "column": {
              "type": "integer",
              "description": "Column number to get runtime values from"
            },
            "expression": {
              "type": "string",
              "description": "Expression to get runtime values for"
            }
          },
          "required": ["file", "line", "lineContent", "expression"]
        },
        "toolReferenceName": "wallaby_runtimeValues",
        "canBeReferencedInPrompt": true,
        "when": "wallaby.startedWithAiAgentTools"
      },
      {
        "name": "wallaby_runtimeValuesByTest",
        "tags": ["runtime values", "logs", "evaluation"],
        "displayName": "Runtime values by test",
        "modelDescription": "Get runtime value at a specific source code location for a specific test. \n\nSupplied line number should be 1-based. When counting lines in a file, do count blank lines as well.\n\n \n\nSupplied test ID should be a valid test identifier acquired from previous Wallaby tools calls.\n\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "description": "File path to get runtime values from"
            },
            "line": {
              "type": "integer",
              "description": "Line number to get runtime values from"
            },
            "lineContent": {
              "type": "string",
              "description": "Full text of the line that contains the expression to get runtime values from"
            },
            "column": {
              "type": "integer",
              "description": "Column number to get runtime values from"
            },
            "expression": {
              "type": "string",
              "description": "Expression to get runtime values for"
            },
            "testId": {
              "type": "string",
              "description": "Test ID to get runtime values for"
            }
          },
          "required": ["file", "line", "expression", "testId"]
        },
        "toolReferenceName": "wallaby_runtimeValuesByTest",
        "canBeReferencedInPrompt": true,
        "when": "wallaby.startedWithAiAgentTools"
      },
      {
        "name": "wallaby_coveredLinesForFile",
        "tags": ["line coverage"],
        "displayName": "Covered lines of file",
        "modelDescription": "Get line numbers of a specific file that are covered by tests and the file's code coverage percentage. If test ID is not supplied, covered lines and coverage percentage for all covering tests will be returned. If test ID is supplied, only covered lines for that test and code coverage percentage for that test will be returned. \n\nSupplied test ID should be a valid test identifier acquired from previous Wallaby tools calls.\n\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "description": "File path to get covered lines for"
            },
            "testId": {
              "type": "string",
              "description": "Test ID to get covered lines for"
            }
          },
          "required": ["file"]
        },
        "toolReferenceName": "wallaby_coveredLinesForFile",
        "canBeReferencedInPrompt": true,
        "when": "wallaby.startedWithAiAgentTools"
      },
      {
        "name": "wallaby_coveredLinesForTest",
        "tags": ["line coverage"],
        "displayName": "Lines covered by test",
        "modelDescription": "Get files and line numbers that are covered by a specific test, or (if file is specified) lines of code of a specific file that are covered by a specific test. Each file contains code coverage percentage calculated for the supplied test only. \n\nSupplied test ID should be a valid test identifier acquired from previous Wallaby tools calls.\n\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "description": "File path to get covered lines for"
            },
            "testId": {
              "type": "string",
              "description": "Test ID to get covered lines for"
            }
          },
          "required": ["testId"]
        },
        "toolReferenceName": "wallaby_coveredLinesForTest",
        "canBeReferencedInPrompt": true,
        "when": "wallaby.startedWithAiAgentTools"
      },
      {
        "name": "wallaby_updateTestSnapshots",
        "tags": ["snapshots"],
        "displayName": "Update snapshots for test",
        "modelDescription": "Update snapshots for a specific test. \n\nSupplied test ID should be a valid test identifier acquired from previous Wallaby tools calls.\n\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "testId": {
              "type": "string",
              "description": "Test ID to update snapshots for"
            }
          },
          "required": ["testId"]
        },
        "toolReferenceName": "wallaby_updateTestSnapshots",
        "canBeReferencedInPrompt": true,
        "when": "wallaby.startedWithAiAgentTools"
      },
      {
        "name": "wallaby_updateFileSnapshots",
        "tags": ["snapshots"],
        "displayName": "Update snapshots for file",
        "modelDescription": "Update snapshots for a specific file. If specified file is a test file, all snapshots in that test file will be updated. If specified file is a source file, all snapshots in all test files that cover that source file will be updated.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "description": "File path to update snapshots for"
            }
          },
          "required": ["file"]
        },
        "toolReferenceName": "wallaby_updateFileSnapshots",
        "canBeReferencedInPrompt": true,
        "when": "wallaby.startedWithAiAgentTools"
      },
      {
        "name": "wallaby_updateProjectSnapshots",
        "tags": ["snapshots"],
        "displayName": "Update project snapshots",
        "modelDescription": "Update all snapshots in the project.",
        "toolReferenceName": "wallaby_updateProjectSnapshots",
        "canBeReferencedInPrompt": true,
        "when": "wallaby.startedWithAiAgentTools"
      },
      {
        "name": "wallaby_failingTests",
        "tags": ["tests", "errors", "failing"],
        "displayName": "Get failing project tests",
        "modelDescription": "Get all failing tests of the project. \n\nEach returned test data includes test name, test ID, errors with stack traces, also runtime logs, global errors, and project's code coverage percentage.\n\n",
        "toolReferenceName": "wallaby_failingTests",
        "canBeReferencedInPrompt": true,
        "when": "wallaby.startedWithAiAgentTools"
      },
      {
        "name": "wallaby_allTests",
        "tags": ["tests"],
        "displayName": "Get project tests",
        "modelDescription": "Get all tests of the project. \n\nEach returned test data includes test name, test ID, errors with stack traces, also runtime logs, global errors, and project's code coverage percentage.\n\n",
        "toolReferenceName": "wallaby_allTests",
        "canBeReferencedInPrompt": true,
        "when": "wallaby.startedWithAiAgentTools"
      },
      {
        "name": "wallaby_failingTestsForFile",
        "tags": ["file tests", "covering tests", "errors", "failing"],
        "displayName": "Get failing tests for file",
        "modelDescription": "Get all related failing tests for a specific file. If specified file is a test file, all failing tests in that test file will be returned. If specified file is a source file, all failing tests in all test files that cover that source file will be returned. \n\nEach returned test data includes test name, test ID, errors with stack traces, also runtime logs, global errors, and project's code coverage percentage.\n\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "description": "File path to get failing test data for"
            }
          },
          "required": ["file"]
        },
        "toolReferenceName": "wallaby_failingTestsForFile",
        "canBeReferencedInPrompt": true,
        "when": "wallaby.startedWithAiAgentTools"
      },
      {
        "name": "wallaby_allTestsForFile",
        "tags": ["file tests", "covering tests"],
        "displayName": "Get tests for file",
        "modelDescription": "Get all related tests covering/executing a specific file. If specified file is a test file, all tests in that test file will be returned. If specified file is a source file, all tests in all test files that cover that source file will be returned. \n\nEach returned test data includes test name, test ID, errors with stack traces, also runtime logs, global errors, and project's code coverage percentage.\n\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "description": "File path to get test data for"
            }
          },
          "required": ["file"]
        },
        "toolReferenceName": "wallaby_allTestsForFile",
        "canBeReferencedInPrompt": true,
        "when": "wallaby.startedWithAiAgentTools"
      },
      {
        "name": "wallaby_failingTestsForFileAndLine",
        "tags": ["line tests", "errors", "failing", "covering tests"],
        "displayName": "Get failing tests for file and line",
        "modelDescription": "Get all related failing tests covering/executing a specific file and line. If specified file is a test file, all failing tests in that test file located at the specified line will be returned. If specified file is a source file, all failing tests in all test files that cover that source file line will be returned. \n\nEach returned test data includes test name, test ID, errors with stack traces, also runtime logs, global errors, and project's code coverage percentage.\n\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "description": "File path to get failing test data for"
            },
            "line": {
              "type": "integer",
              "description": "Line number to get failing test data for"
            },
            "lineContent": {
              "type": "string",
              "description": "Full text of the line to get failing test data for"
            }
          },
          "required": ["file", "line", "lineContent"]
        },
        "toolReferenceName": "wallaby_failingTestsForFileAndLine",
        "canBeReferencedInPrompt": true,
        "when": "wallaby.startedWithAiAgentTools"
      },
      {
        "name": "wallaby_allTestsForFileAndLine",
        "tags": ["line tests", "covering tests"],
        "displayName": "Get tests for file and line",
        "modelDescription": "Get all related tests covering/executing a specific file and line. If specified file is a test file, all tests in that test file located at the specified line will be returned. If specified file is a source file, all tests in all test files that cover that source file line will be returned. \n\nEach returned test data includes test name, test ID, errors with stack traces, also runtime logs, global errors, and project's code coverage percentage.\n\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "description": "File path to get test data for"
            },
            "line": {
              "type": "integer",
              "description": "Line number to get test data for"
            },
            "lineContent": {
              "type": "string",
              "description": "Full text of the line to get test data for"
            }
          },
          "required": ["file", "line", "lineContent"]
        },
        "toolReferenceName": "wallaby_allTestsForFileAndLine",
        "canBeReferencedInPrompt": true,
        "when": "wallaby.startedWithAiAgentTools"
      },
      {
        "name": "wallaby_testById",
        "tags": ["test"],
        "displayName": "Get test by ID",
        "modelDescription": "Get test data by test ID. \n\nSupplied test ID should be a valid test identifier acquired from previous Wallaby tools calls.\n\n \n\nEach returned test data includes test name, test ID, errors with stack traces, also runtime logs, global errors, and project's code coverage percentage.\n\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "testId": {
              "type": "string",
              "description": "Test ID to get test data for"
            }
          },
          "required": ["testId"]
        },
        "toolReferenceName": "wallaby_testById",
        "canBeReferencedInPrompt": true,
        "when": "wallaby.startedWithAiAgentTools"
      }
    ]
  }
]
